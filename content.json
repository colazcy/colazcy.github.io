{"pages":[],"posts":[{"title":"Codeforces Global Round 10","text":"Codeforces Global Round 10 A.Omkar and Password 题意：给定一个长为 \\(n\\) 的序列 \\(a\\)，对于两个相邻且不同的数，你可以将它们合并。即将这两个数替换为它们的和。你可以进行多次操作，问最后序列长度最短是多少。 如果一开始就全相等是 \\(n\\)，否则答案是 \\(1\\)。 B.Omkar and Password 题意：给定一个长为 \\(n\\) 的序列 \\(a\\) 以及一个 \\(k\\)，定义一次操作为：设 \\(d\\) 表示序列中的最大值，\\(\\forall i \\in [1,n]\\)，\\(a_i \\leftarrow d - a_i\\) 求 \\(k\\) 次操作后的序列。 把序列排好序，求出原序列每个数对应排好序之后的哪个数。 对于排好序的序列，它操作两次相当于没有操作并且非常好表示。 C.Omkar and Waterslide 题意：给定一个长为 \\(n\\) 的序列 \\(a\\)，每次操作选择一段不下降的区间 \\([l,r]\\)，将区间内的数 \\(+1\\)。问最少需要多少次操作可以让序列变成一个不下降的序列。 先贪心求出在最优情况下每个元素操作后变成了哪个数，算出它们的差值。之后就是积木大赛了。 D.Omkar and Bed Wars 题意：有 \\(n\\) 个人正在进行 Bed War。这 \\(n\\) 个人排列成环状。每个人会攻击自己左边或者右边相邻的一个人。 一个合法的攻击状态满足： 如果 \\(a\\) 攻击 \\(b\\)，且 \\(b\\) 只受到 \\(a\\) 的攻击时，\\(b\\) 必须攻击 \\(a\\)。 如果 \\(a\\) 被旁边两个人同时攻击或者旁边两个人都不攻击他，那么他可以随意选择一个人攻击。 给定初始状态，求最少需要改变多少个人的攻击方向才能够使攻击状态合法。 分类讨论，发现连续三个人之间的可能状态只有 \\(6\\) 种情况，直接枚举第 \\(1,2\\) 个人的状态然后 \\(dp\\) E.Omkar and Duck 本题是一道交互题 题意：给定一个正整数 \\(n\\)，你需要构造并输出一个 \\(n \\times n\\) 的矩阵 \\(a\\)。我们定义一条路径为从 \\(a_{1,1}\\) 开始，每次向下或者向右走一格，最终到达 \\(a_{n,n}\\) 的元素集合。在你输出矩阵后会给定 \\(q\\) 组询问。每次交互库会从你给出的矩阵里面随意找一条路径，告诉你路径上元素的和。你需要找出这条路径，并且保证这条路径唯一。 题意等价于让你构造一个 \\(n \\times n\\) 的矩阵 \\(a\\) 且所有路径的和两两不同。 路径的条数等于我们行走的方案数。如果把 \\(0,1\\) 分别看做向 右 / 下 走，那么我们可以用一个长为 \\(2(n-1)\\) 的字符串来表示行走方案。这启示我们按照行走方案的字典序指定每一条路径的和。 求行走方案的排名以及由排名求方案就是类似于康拓展开的东西。 而我们填数则按照行递增列递减的顺序填数，这样每条路径只有一个点是未知的，其它的都已经填了。 F.Omkar and Landslide 题意：有一些山发生了山体滑坡。这些山从左到右以此排布，第 \\(i\\) 座山的高度是 \\(h_i\\)，并且 \\(\\forall i \\in [1,n),h_i&lt;h_{i+1}\\)。每一时刻，假如 \\(h_i+2\\leq h_{i+1}\\)，那么两座山的高度会发生变化，即 \\(h_i \\leftarrow h_i+1,h_{i+1} \\leftarrow h_{i+1} - 1\\)。所有山高度的变化是同时发生的。求滑坡进行完，没有泥土可以流动时，所有山的高度。 发现最后山的高度满足 \\(|h_i - h_{i+1}| \\leq 1\\)，且最多只有一个 \\(i\\) 满足 \\(h_i=h_{i+1}\\)。 也就是末序列只由初序列的和决定。那么我们可以二分首元素，将剩下的 \\(x\\) 依次填到前 \\(x\\) 个元素。","link":"/2021/04/17/Codeforces%20Global%20Round%2010/"},{"title":"Codeforces Global Round 11","text":"Codeforces Global Round 11 A.Avoiding Zero 题意：给你一个序列 \\(a\\)，把它重排，使得不存在一个和为 \\(0\\) 的前缀。 如果全部数的和为 \\(0\\) 则无解。 否则从小到大排和从大到小排之间必有一合法方案。 B.Chess Cheater 题意：你参加了 \\(n\\) 场比赛，每场游戏要么赢要么输（无平局）。比赛的计分规则如下： 输掉一场比赛得 \\(0\\) 分。 赢得一场比赛时，若上一局比赛也赢了，则这场比赛得 \\(2\\) 分，否则得 \\(1\\) 分。 如果第一局比赛就赢了，得 \\(1\\) 分。 输赢结果由一段长为 \\(n\\) 的字符串表示。你可以修改最多 \\(k\\) 个字符，最大化你的分数。 首先把所有连续输的段找出来。先从中间考虑，再考虑首为 \\(1\\) 或者尾为 \\(n\\) 的段。从小到大尽量填就行了。 C.The Hard Work of Paparazzi 题意：有一个 \\(r \\times r \\quad r \\leq500\\) 的平面。从一个点移动到另一个点的时间为这两点之间的曼哈顿距离。 有 \\(n\\) 位名人会出现，其中第 \\(i\\) 位名人会在第 \\(t_i\\) 分钟出现在点 \\((x,y)\\)。且 \\(\\forall i \\in [1,n),t_i &lt; t_{i+1}\\) 第 \\(0\\) 分钟你在点 \\((x,y)\\) ，求你最多可以拍到多少个名人。 考虑 dp，记 \\(f[i]\\) 表示最后拍第 \\(i\\) 位名人的前提下，我们最多可以拍到多少个名人。 \\(f[i]=\\max\\{f[j]+1\\}\\) 其中 \\(j\\) 满足拍完第 \\(j\\) 位名人后可以赶来拍第 \\(i\\) 位名人。 考虑关键性质 \\(r \\leq 500\\)，两点之间的曼哈顿距离不会超过 \\(1000\\)，因此我们向前暴力找 \\(2r\\) 个，剩下的通过前缀 \\(\\max\\) 快速转移。 D.Unshuffling a Deck 题意：给定一个长为 \\(n\\) 的排列。你可以用以下操作将它们排序：任选 \\(k \\in[2,n]\\) 并将排列分为 \\(k\\) 个连续非空部分，每部分有 \\(D_1,D_2,\\cdots,D_k\\) 个数。然后我们翻转这 \\(k\\) 个部分，排列变为 \\(D_k,D_{k-1},\\cdots,D_1\\)。每个部分内的顺序不会改变。 构造一种方案，用至多 \\(n\\) 次操作将序列排好序。 我们维护已经排好序的前缀，之后用 \\(2\\) 次操作将两个数添加到后面。通过讨论要添加的两个数之间的位置关系，这个是非常好完成的。 E.Xum 题意：黑板上一开始有一个正奇数 \\(x\\)，每次可以选择黑板上已有的两个数 \\(a,b\\)，将 \\(a+b\\) 或者 \\(a\\;xor\\;b\\) 写在黑板上。构造一种方案把 \\(1\\) 写在黑板上。 要把 \\(1\\) 写在黑板上代表我们要把 \\(x\\) 其它位上的 \\(1\\) 全部消除。 我们可以每次消除最高位，递归完成。 我们先将 \\(x\\) 左移，使得最低位的 \\(1\\) 与原来最高位的 \\(1\\) 对齐，将这个数记为 \\(y\\)。取 \\(x,y\\) 的异或和，记为 \\(z\\)。我们就消去了 \\(x\\) 的最高位。 我们再求出 \\(z+y\\)，记为 \\(r\\)。\\(r\\) 的低位和 \\(z\\) 相同，而高位为 \\(y\\) 除去最低位的 \\(1\\) 左移一位。在 \\(x\\) 的最高位 \\(1\\) 的位置，\\(r\\) 为 \\(1\\)。 我们将 \\(r\\) 异或上 \\(x\\)，再异或上 \\(y+y\\)。我们就得到了恰比 \\(x\\) 的最高位 \\(1\\) 还高 \\(1\\) 位 的 \\(1\\)。 用这个 \\(1\\) 消去 \\(z\\) 里面所有高位 \\(1\\)，就得到了 \\(x\\) 消去最高位 \\(1\\) 之后的数。","link":"/2021/04/16/Codeforces%20Global%20Round%2011/"},{"title":"Codeforces Global Round 12","text":"Codeforces Global Round 12 A.Avoid Trygub 题意：给定一个字符串，将它重排，使得不存在子序列 \"trygub\"。 直接把六个字母拖出来，按照\"bugyrt\"的顺序放到末尾。 B.Balls of Steel 题意：给定 \\(n\\) 个点和常数 \\(k\\)，定义一次操作为选定一个点，将所有和它之间曼哈顿距离不超过 \\(k\\) 的点全部移到它的位置（点可以重叠）。问可不可能将所有点移到一个位置。 一次操作可以的话就可以，否则不行。 C.Errich-Tac-Toe 题意：给定一个 \\(n \\times n\\) 的字符串矩阵。字符集为 \\(\\{\\text{X},\\text{O},\\text{.}\\}\\)。记所有非 \\(\\text{.}\\) 位置的数量为 \\(S\\)，你可以将不超过 \\(\\lfloor \\frac{S}{3} \\rfloor\\) 个位置的 \\(\\text{X}\\) 变为 \\('\\text{O}'\\) 或者 \\(\\text{O}\\) 变为 \\(\\text{X}\\)。使得每行每列都不存在三个连续的\\(\\text{X}\\) 或者 \\(\\text{O}\\)。简单版初始矩阵没有 \\(\\text{O}\\) 字符。 考虑简单版，位置从 \\(0\\) 开始。我们按照 \\((i + j) \\bmod 3\\) 的余数对位置进行分类，将其中一个类全部变为 \\(\\text{X}\\) 。取改变最小的那一个。 困难版本这么做会超过改变限制，原因是我们并不需要钦定三个类，我们只需要钦定两个类让它们字符不同，剩下一个类无论取啥字符都合法。六种情况枚举一下取合法方案就可以了。 D.Rating Compression 题意：给定一个长为 \\(n\\) 的序列 \\(a\\) 。定义 \\(k\\)-compression 可以得到一个长为 \\(n - k + 1\\) 的序列，其中 \\(b_j = \\min_{i\\in [j,j+k-1]}a_i\\)$。对于 $\\(\\forall k\\in[1,n]\\)，求 \\(k\\)-compression 之后得到的序列是不是一个排列。 首先判掉 \\(k = 1\\) 的情况。 然后手玩一下样例可以发现，如果 \\(1\\) 只在最前面或者最后面出现，那么是不会影响其他元素的。否则如果 \\(1\\) 在中间或者两边都出现，我们只可能在 \\(k = n\\) 的时候才能得到一个排列。（最小的元素一直在中间，每次都会把相邻元素变成它） 递归下去，我们就要对剩下的 \\(n - 1\\) 个元素考虑 \\(2\\) 的位置。归纳一下，可以发现除了 \\(k = 1\\)，合法的 \\(k\\) 是一个后缀连续段。所以可以二分。 E.Capitalism 这题目名字取得好哇 题意：给定一张 \\(n\\) 个点 \\(m\\) 条边的无向连通图。每个点有一个权值 \\(a_i\\)，对于每一条边 \\((u,v)\\)，它钦定了 \\(a_v = a_u + 1\\)，或者 \\(|a_u-a_v|=1\\)。问是否能构造一组 \\(a\\) 满足 \\(m\\) 个约束条件。如果可以，求 \\(\\max a_i - \\min a_i\\) 的最大值。 这个东西一脸的差分约束。。。 首先如果不是二分图一定无解。 第一类约束显然，第二类约束我们转化为 \\(-1 \\leq a_u - a_v \\leq 1\\)。关键问题在于，我们要保证不会出现 \\(a_u = a_v\\) 的状况…… 然后发现因为这个图是二分图所以我们一定会取到上下界之一。因为如果你走偶数条边让 \\(a_u = a_v\\)，那么就不可能有边 \\((u,v)\\) 了否则出现奇环。 那么我们直接跑 Floyd，枚举作为最小值的点就行了。如果出现 \\(dis[s][u]=dis[s][v]\\) ，并且有边 \\((u,v)\\) 那么就无解。有负环也无解。 F.The Struggling Contestant 题意：给定一个长为 \\(n\\) 的序列 \\(a\\)。定义一个排列 \\(p\\) 合法为 \\(\\forall i\\in[1,n)\\quad a_{p_i} \\neq a_{p_{i + 1}}\\)。一个排列的代价为\\(|p_{i+1}-p_i|&gt;1 \\quad i\\in[1,n)\\) 的 \\(i\\) 的个数。求最小代价。 记出现次数最多的元素的出现次数为 \\(x\\)，有解等价于 \\(n-x \\geq x - 1\\)。 否则我们要在所有 \\(a_i=a_{i+1}\\) 的位置断开。问题变成给你一些线段，你可以将它们任意重排、任意交换一条线段的两个端点，使得最后得到的线段序列相邻端点颜色不同。 我们记录出现次数最多的端点的出现次数为 \\(mx\\)，并且我们将序列切了 \\(k\\) 次（切成了 \\(k + 1\\) 段）。 如果 \\(mx &lt; k + 2\\) 那么我们就可以将出现次数最多的端点任意分配到 \\(k + 2\\) 个位置里面。否则我们还要切 \\(mx - (k+2)\\) 次。因为我们已经判断了无解的情况，所以一定可以切出来。 也就是，答案为 \\(k + \\max(0,mx-(k+2))\\)。 G,H 也许以后会补？大概率鸽掉了","link":"/2021/04/14/Codeforces%20Global%20Round%2012/"},{"title":"Codeforces Global Round 14","text":"Codeforces Global Round 14 A.Phoenix and Gold 题意：给定一个长为 \\(n\\) 的序列 \\(w\\) 和一个数 \\(x\\)，序列中没有相同元素。要求对这个序列进行重排，使得 \\(\\forall i\\in[1,n] \\quad \\sum_{j=1}^iw_j \\neq x\\)。 由于没有相同元素且 \\(n\\) 很小，直接随机化是非常稳的。 也有确定性算法。如果 \\(\\sum w_i=x\\) 那么无解。否则我们按照从大到小的顺序放置 \\(w\\)，如果放置一个数之后前缀和为 \\(x\\) 就把这个数提出去，把其他数放完再将它接到末尾。 B.Phoenix and Puzzle 题意：给定 \\(n\\)，求恰好用 \\(n\\) 个全等的等腰直角三角形能否拼成一个正方形。 Solution 1 Solution 2 如果 \\(\\frac{n}{2}\\) 或 \\(\\frac{n}{4}\\) 是一个完全平方数那么可行。 C.Phoenix and Towers 题意：给定 \\(x\\)，有 \\(n\\) 个方块，第 \\(i\\) 个方块的高度为 \\(h_i\\)。把 \\(n\\) 个方块分为 \\(m\\) 叠，要求不存在两叠使得它们之间的高度差 \\(&gt; x\\)。 显然的贪心做法，按从小到大的顺序放置方块，每次放置到最矮的一叠上。 D.Phoenix and Socks 题意：有 \\(n\\) 只袜子，其中有 \\(l\\) 只左袜子，\\(r\\) 只右袜子。第 \\(i\\) 只袜子颜色为 \\(c_i\\)。现在可以进行三种操作，每种操作代价均为 \\(1\\)：将某只袜子颜色换为 \\(c'\\)；将左袜子变为右袜子；将右袜子变为左袜子。求配对成 \\(\\frac{n}{2}\\) 只袜子的最小代价。 首先把能配对的都配对了。 现在对于每种颜色要么全是左袜子要么全是右袜子，将它们中的一半配对了。此时要保证左右袜子数量一样多。 接着同种类袜子中变换颜色即可。 E.Phoenix and Computers 题意：给定 \\(n\\)。有 \\(n\\) 台电脑排成一排，你需要打开所有电脑。你可以手动打开一台电脑。在任意时刻，若电脑 \\(i - 1\\) 和电脑 \\(i + 1\\) 都已经打开，那么电脑 \\(i\\) 将自动打开。你不能打开一台正在运行的电脑。求有多少种打开电脑的方案，两个方案不同当且仅当手动打开电脑的集合不同，或者手动打开电脑的顺序不同。 首先手动打开的电脑形成了若干连续段，且这些连续段之间的间隔恰好为 \\(1\\)。 我们预处理出长为 \\(len\\) 的连续段内部的打开方案数记为 \\(d[len]\\)，这个可以通过枚举第一台打开的电脑来实现。 我们设 \\(f[i][j][opt]\\) 表示前 \\(i\\) 台电脑内打开 \\(j\\) 台电脑，\\(opt = 0\\) 表示末尾电脑手动打开，\\(opt = 1\\) 表示没有手动打开的方案数。那么答案为 \\(\\sum f[n][i][0]\\)。 那么： \\[ \\begin{align} f[i][j][1]&amp;=f[i-1][j][0]\\\\ f[i][j][0]&amp;=\\sum \\binom{j}{k}\\cdot d[k]\\cdot f[i-k][j-k][1] \\end{align} \\] F.Phoenix and Earthquake 题意：给定一张无向图，以及正权值 \\(x\\)，每个点有一个权值 \\(a_i\\)。如果一条边 \\((u,v)\\) 满足 \\(a_u+a_v\\geq x\\)，可以将 \\(u,v\\) 缩点，新点的权值为 \\(a_u+a_v-x\\)。 求一种方案，将整张图缩成一个点。 考虑贪心，每次找权值最大的点，随便找个邻居缩点。 使用优先队列维护权值最大的点，并查集维护缩点。可以使用链表维护出边，这样可以使用 splice \\(O(1)\\) 合并两个点的出边。 G.Phoenix and Odometers 题意：给定一张带权有向图。每次询问给出 \\(v,s,t\\)，求是否存在一条从 \\(v\\) 出发回到 \\(v\\) 的路径（不一定是简单路径），使得路径长度 \\(\\equiv t-s \\pmod{t}\\)。 我们只需要考虑 \\(v\\) 所在的强联通分量。设其中简单环的权值和为 \\(c_i\\)，那么根据裴蜀定理，路径存在等价于 \\(\\gcd(c_1,c_2,\\cdots,c_k,t) \\mid t-s\\)。 简单环可以有多条非树边，但它们都可以用恰有 \\(1\\) 条非树边的环表示出来。","link":"/2021/05/11/Codeforces%20Global%20Round%2014/"},{"title":"Codeforces Global Round 8","text":"Codeforces Global Round 8 A.C+= 题意：有三个正整数 \\(a,b,n\\)，每一轮可以执行以下操作之一： 将 \\(a\\) 增加 \\(b\\)。 将 \\(b\\) 增加 \\(a\\)。 求最小轮数，使得 \\(a,b\\) 中有一个数严格大于\\(n\\)。 每次将小的数加上大的数，这样每一轮至少翻倍，轮数在 \\(log\\) 级别。 B.Codeforces Subsequences 题意：求最短的，至少有 \\(k\\) 个子序列为 \\(\\texttt{codeforces}\\) 的字符串。 最终答案形如 \\(\\texttt{ccooddeeffoorrcceess}\\)，和一定的情况下，差越小积越大。我们直接均分。 C.Even Picture 题意：在一个网格图上给格子染色，要求所有被染色的格子连通，且与偶数个被染色的格子相邻。构造一种合法方案，使得恰好有 \\(n\\) 个被染色的格子四周的格子都被染色。 Solution 1 Solution 2 D.AND, OR and square sum 题意：给定 \\(n\\) 个非负整数 \\(a_1,a_2,\\cdots,a_n\\)。定义一次操作为：选择两个不同的 \\(i,j\\)，满足 \\(i,j \\in[1,n]\\)，令 \\(a_i \\leftarrow a_i\\) AND \\(a_j\\)，\\(a_j \\leftarrow a_i\\) OR \\(a_j\\)，两个赋值同时进行。你可以进行若干次操作，求操作后 \\(\\sum a_i^2\\) 的最大值。 按位考虑，一次操作等价于将某一位上的 \\(1\\) 从一个数移到了另一个数，因而所有数字的总和是不会改变的。所以我们直接统计出每一位上有多少个 \\(1\\)，贪心的构造出尽可能大的数。 另：有 \\(x\\) OR \\(y=x+y-(x\\) AND \\(y)\\) E.Ski Accidents 题意：给定一张 \\(n\\) 个点 \\(m\\) 条边的 DAG，每个点出度不超过 \\(2\\)。你需要标记一些点（不超过 \\(\\frac{4}{7}n\\) 个），标记一个点 \\(u\\) 将会删除所有和 \\(u\\) 连接的边。求一种标记点的方案，使得删边之后的图中每一条路径至多有 \\(1\\) 条边。 \\(\\frac{4}{7}n\\) 这个数字也许可以带来一些启发。对于一个恰有 \\(7\\) 个点的满二叉树，我们删去所有叶子节点就可以得到一张合法的图。 仿照上述做法，我们将 DAG 划分为三组： A 组：入度为 \\(0\\)，或者所有入边都来自 C 组。 B 组：至少有 \\(1\\) 条入边来自 A 组，但没有来自 B 组的入边。 C 组：至少有 \\(1\\) 条入边来自 B 组。 由于所有点的出度都不超过 \\(2\\)，所以 \\(2|A| \\geq |B|\\)。同理 \\(2|B| \\geq |C|\\)。所以 C 组的顶点数目不超过 \\(\\frac{4}{7}n\\)。将 C 组中点全部删除即可得到一张合法的图。 F.Lamps on a Circle 本题是一道交互题。 题意：Alice 和 Bob 又双叒叕在玩游戏。有 \\(n\\) 盏灯排成一个环，顺时针编号为 \\(1-n\\)。初始时所有灯都是关着的。 定义一轮操作为： Alice 选择一个 \\(k \\in [1,n]\\)，然后打开任意 \\(k\\) 盏灯（可以重复打开）。 Bob 关闭一段长度为 \\(k\\) 的区间的灯。 设 \\(R\\) 表示经过若干轮之后开着的灯的数量的最大值，你需要帮助 Alice 达到这个上界。 首先如果我们打开 \\(k\\) 盏灯之后，开着的灯形成了一个长为 \\(k\\) 的连续段。那么 Bob 就可以关掉这个连续段里面的灯。设 \\(now\\) 表示当前亮着的的数量，有：\\(now+k+\\frac{now+k}{k-1} \\leq n\\)。所以 \\(now \\leq n - k - \\frac{n}{k}+1\\)。假设我们已经找到了这么一个 \\(k\\) 使得 \\(n - k - \\frac{n}{k} + 1\\) 取到最大值，我们这样构造方案： 将 \\(1,k+1,2k+1,\\cdots\\) 这些位置标记，我们永远也不会打开它们，这样开着的灯就永远不会出现长为 \\(k\\) 的连续段 Alice 每次从可以打开的灯里面任意打开 \\(k\\) 盏，如果能打开的灯不足 \\(k\\) 盏则已经取到了最大值。","link":"/2021/04/21/Codeforces%20Global%20Round%208/"},{"title":"Codeforces Global Round 7","text":"Codeforces Global Round 7 A.Bad Ugly Numbers 题意：构造一个 \\(n\\) 位十进制数，使得这个数不被它任意一位整除。 直接构造 23333333 B.Maximums 题意：有序列 \\(a,b,c\\)，其中 \\(c_n = \\max(\\max_{i=1}^{n-1} a_i,0)\\)，\\(b_i=a_i-c_i\\)，给定序列 \\(b\\)，求序列 \\(a\\)。 直接顺着推过去就行。 C.Permutation Partitions 题意：给定一个长为 \\(n\\) 的排列 \\(p\\)。要求把这个排列分为 \\(k\\) 段，使得每段内最大值的和最大，求方案数。 我们肯定取前 \\(k\\) 大的数，每个数在一段，方案数根据乘法原理算一下就行。 D.Prefix-Suffix Palindrome 题意：给定一个字符串，要求选取该字符串的一个前缀（可以为空），选取该字符串的一个后缀（可以为空），且它们不相交。将选取的前缀和后缀拼接成一个新字符串，要求这个字符串是一个回文串，求该回文串的最大长度。 首先我们从原串两侧选取，这样选出来一定是一个回文串只不过长度不一定最大。我们记还没有被选的区间为 \\([l,r]\\)，那么我们从 \\([l,r]\\) 的所有前缀和后缀里面选一个最长的回文串接在中心就可以了。可以用 Hash 来做。 E.Bombs 后补 F1.Wise Men (Easy Version) 题意：有 \\(n\\) 个人。给定一个 \\(n \\times n\\) 的 \\(01\\) 矩阵 \\(G\\) 表示这 \\(n\\) 个人之间的认识情况。一个长为 \\(n\\) 的排列 \\(p\\) 可以生成一个长为 \\(n - 1\\) 的 \\(01\\) 串 \\(s\\)，其中 \\(s_i = G[p_i][p_{i+1}]\\)。对于 \\(2^{n-1}\\) 种 \\(01\\) 串 ，统计有多少种排列可以生成它。\\(n \\leq 14\\)。 首先有一个暴力 dp。设 \\(f[s][t][end]\\) 表示排列中元素的集合为 \\(s\\)，排列的末尾元素为 \\(end\\)，形成 \\(01\\) 串 \\(t\\) 的方案数。 这样无法接受，考虑折半。我们只 \\(dp\\) 出 \\(|s| \\leq 10\\) 的部分，剩余部分我们枚举排列暴力合并。","link":"/2021/04/28/Codeforces%20Global%20Round%207/"},{"title":"Codeforces Global Round 9","text":"Codeforces Global Round 9 A.Sign Flipping 题意：给定一个长为 \\(2k+1\\) 的整数数组 \\(a\\)。给每个数配上正负号。使得最终数组至少有 \\(k\\) 对相邻数差值小于等于 \\(0\\)，至少有 \\(k\\) 对相邻数差值大于等于 \\(0\\)。 直接按照 \\(+,-,+,-,\\cdots\\) 的顺序配就可以了。 B.Neighbor Grid 题意：给定一个 \\(n \\times m\\) 的非负矩阵。 好矩阵的定义： 如果当前格子内是一个正整数 \\(k\\)，那么恰好有 \\(k\\) 个格子与它有公共边且里面是一个正整数。 如果这个格子是 \\(0\\) 那么没有限制。 你可以给每个格子都加上任意的一个数，求是否可以把这个矩阵变成好的。如果可以输出变换之后的矩阵。 直接钦定每个格子内都是正整数。 C.Element Extermination 题意：给定一个长为 \\(n\\) 的排列 \\(a\\)。定义一次操作为：选择一个满足 \\(a_i&lt;a_{i+1}\\) 的下标 \\(i\\)，删除 \\(a_i\\) 或 \\(a_{i+1}\\)。求是否可以通过若干次操作使得 \\(a\\) 只剩下一个元素。 如果 \\(a[1] &lt;a[n]\\) 可以，否则不行。 D.Replace by MEX 题意：给定一个长为 \\(n\\) 的序列 \\(a\\)。定义一次操作为：选择一个位置 \\(p\\)，\\(a_p \\leftarrow\\) 这个序列的 \\(mex\\)。用不超过 \\(2n\\) 次操作使得这个序列单调不降。 直接把序列变成 \\(0,1,\\cdots,n-1\\)。（下标从 \\(0\\) 开始） 我们每一轮都求这个序列的 \\(mex\\)。 \\(mex \\neq n\\)，令 \\(a_{mex}\\leftarrow mex\\)。 \\(mex =n\\)，这个时候原序列可能是一个错误的排列。我们找到 \\(a_p \\neq p\\) 的位置 \\(p\\)，令 \\(a_p \\leftarrow mex\\)。 E.Inversion SwapSort 后补 F.Integer Game 本题是交互题。 题意：给定三个数，分别为 \\(a,b,c\\)。每一轮先手给定一个数 \\(k\\)，后手需要将某一个数加上 \\(k\\)。规定后手不能连续加给同一个数。当存在两个数相等时先手胜，轮数超过 \\(1000\\) 后手胜。给定 \\(a,b,c\\) 后你可以自行决定当先手还是后手。 先手必胜。由于三个数顺序无关，我们假定 \\(a &lt; b &lt; c\\)。第一轮给出 \\(2c-a-b\\)。 加给 \\(a\\)，三个数为 \\(2c-b,b,c\\)，下一轮给出 \\(c-b\\)。 加给 \\(b\\)，三个数为 \\(a,2c-a,c\\)，下一轮给出 \\(c-a\\)。 加给 \\(c\\)，三个数为 \\(a,b,3c-a-b\\)，由于 \\(a&lt;b&lt;c\\)，所以 \\(a&lt;b&lt;3c-a-b\\)。这是一个子问题，但是下一轮后手不能加给 \\(c\\) 了，所以必胜。 G.Tree Modification 题意：给定一棵树。定义一次操作为： 选定三个相邻的点 \\(a,b,c\\)，要求 \\(a,b\\) 相邻，\\(b,c\\) 相邻。 把所有和 \\(a\\) 相邻的点（除了 \\(b\\) ），断掉它们和 \\(a\\) 的连边，将它们接到 \\(c\\) 上。 删除 \\(a,b\\) 之间的连边，将 \\(a\\) 接到 \\(c\\) 上。 求最小的操作次数，使得这棵树变成一个菊花图。 首先树是一个二分图，而菊花图是特殊的二分图。 假设我们以最后度数变为 \\(n - 1\\) 的那个点为根。那么每一次操作其实是选定一个点，将它和它的所有儿子都接到它的祖父上。如果将原图黑白染色那就等价于改变一个点的颜色。 记黑白两点的个数为 \\(black,white\\)，答案为 \\(min(black,white)-1\\)。","link":"/2021/04/17/Codeforces%20Global%20Round%209/"},{"title":"Codeforces Round #591","text":"Codeforces Round #591 A.Save the Nature 题意比较令人迷惑。直接贪心即可，先选 \\(\\operatorname{lcm}(a,b)\\) 位置的，再选 \\(\\max(x,y)\\) 的，再选 \\(\\min(x,y)\\) 的。直接二分答案。 Code B.Sequence Sorting 题意：给定一个长为 \\(n\\) 的序列 \\(a\\)。每次操作可以选择一个 \\(x\\)，将所有 \\(x\\) 移到开头，或末尾。求最小操作次数使得整个序列排好序。 \\(n\\leq 3\\times 10^5,a_i\\leq n\\)。 2s，256M。 我们将值域的前缀移到序列开头，将值域的后缀移到序列末尾。中间要求已经有序。 对于每个权值 \\(x\\)，我们预处理出 \\(L[x],R[x]\\) 表示两端 \\(x\\) 的位置。 即求 \\([l,r]\\)，满足 \\(\\forall i \\in [l,r), R[i]&lt;L[i + 1]\\)。然后更新答案。 显然求极长 \\([l,r]\\)，一脸的 two-pointer。 Code C.Paint the Tree 题意：给定一棵 \\(n\\) 个点的带权树，以及常数 \\(k\\)。从树上选若干条边，选一条边则标记两端点，要求所有点被标记次数不超过 \\(k\\)。求权值和最大的选择方案。 \\(n,k\\leq 5\\times10^5\\)。 2s，256M。 现场没切，转化为二分图反而丢失了树的重要性质。 考虑树形 dp，记 \\(f[u][0/1]\\) 表示在子树 \\(u\\) 中选边，\\(u\\) 被标记次数不超过 \\(k/k-1\\) 的最大权值和。 显然所有 \\(f[v][0]\\) 都是可以选择的。再从所有 \\(\\max(0,f[v][1] - f[v][0] - e.v)\\) 选择最大的 \\(k/k-1\\) 个即可。 Code D.Stack Exterminable Arrays 题意：对于一个序列 \\(a\\)，我们维护一个初始为空的栈。对于每个 \\(a_i\\)，如果栈为空或者栈顶不为 \\(a_i\\)，我们将 \\(a_i\\) 入栈，否则弹栈。如果最后栈为空，那么称这个序列是好的。 给定一个长为 \\(n\\) 的序列 \\(v\\)，求其有多少个好的连续子序列。 \\(n\\leq 3\\times 10^5,v_i\\leq n\\)。 2s，256M。 有一个经典的 trick，我们维护序列前缀操作后的栈。如果在 \\(l,r\\) 处，两前缀的栈是相同的，那么 \\((l,r]\\) 这个序列是好的。 可以用 Trie 树来维护，每次将前缀栈插到 Trie 树里面就可以统计每种栈的出现次数。这样是 \\(n^2\\) 的。考虑继承，如果是入栈 \\(x\\)，我们往 \\(x\\) 对应的儿子走，否则往父亲走。用 std::map 替代邻接矩阵即可。 Code E.Wooden Raft 题意：给定 \\(n\\) 根木棍，第 \\(i\\) 根木棍的长为 \\(a_i\\)。建造木筏需要 \\(2\\) 根长为 \\(x\\) 的木棍，和 \\(x\\) 根长为 \\(y\\) 的木棍。\\(2 \\leq x,y\\)。可以切割木棍，但是不能将两根木棍拼在一起。 求木筏的最大面积。 \\(n \\leq 5\\times 10^5,2 \\leq a_i \\leq 5\\times10^5\\) 2s，256M。 考虑枚举。相比枚举 \\(x\\)，枚举 \\(y\\) 钦定了每根木棍切割后的长度，是更强的约束。 因为枚举 \\(y\\) 之后，我们将每根木棍切成若干个长为 \\(y\\) 的段和多余部分。因此我们考虑枚举 \\(x = ky+r\\)。即枚举 \\(k\\)，\\(x\\in [ky,ky + y)\\)。 接着考虑不切哪些木棍。分两种情况。 记 \\(cnt = \\sum\\lfloor \\frac{a_i}{k}\\rfloor\\)。 1.\\(x\\) 由一根木棍切割而来，此时我们相当于枚举 \\(2x \\in [ky,ky + y)\\)。\\(2x\\) 的最大值为 \\(ky + \\max\\{a_i \\bmod y | a_i \\geq ky\\}\\)，此时剩下 \\(cnt - k\\) 根长为 \\(y\\) 的木棍。倒序枚举 \\(k\\) 即可。 2.\\(x\\) 由两根木棍切割而来，此时我们相当于枚举 \\(x \\in [ky,ky + y)\\)。 我们需要维护 \\(\\max\\{a_i \\bmod y | a_i \\geq ky\\}\\) 的最大值和次大值。 取次大值时容易计算，此时剩下 \\(cnt - 2k\\) 根木棍。 取最大值稍有些麻烦，此时我们还需要拿出一段长为 \\(y\\) 的木棍让次大值变为最大值。由于木棍不能互相拼接，因此我们要求木棍的长度至少为 \\((k+1)y\\)。此时还剩下 \\(cnt - 2k - 1\\) 根木棍。 复杂度调和级数。细节见代码。 Code F.Football 简化后的题意：给定一张 \\(n\\) 个点 \\(m\\) 条边的无向图，以及常数 \\(k\\)。你需要将每条边染上 \\([1,k]\\) 内的颜色，使得对于每个点，其邻边中颜色出现次数的极差不超过 \\(2\\)。构造方案。 \\(n \\leq 100,m,k \\leq 1000\\)。 1s，256M。 原图没有很好的性质，我们将其转化为二分图。即原图中有边 \\((u,v) \\quad u \\leq v\\)，连边 \\((u,v + n)\\)，这样我们就将原图转化为了一个二分图。只要二分图中极差不超过 \\(1\\)，合并之后极差就不会超过 \\(2\\)。 现在已经变成了这个问题。 我们考虑拆点以获得更强的约束。对于一个度数为 \\(ak+b\\) 的点，我们将其拆为 \\(a\\) 个度数为 \\(k\\) 的点和一个度数为 \\(b\\) 的点。这样我们只需要每个点邻边的颜色互不相同。 类似于匈牙利算法，我们每次加边 \\((u,v)\\) 后，做出调整使得染色方案符合约束。 记 \\(u\\) 的邻边中颜色 \\(ca\\) 没有出现过，\\(v\\) 的邻边中颜色 \\(cb\\) 没有出现过。 若 \\(ca=cb\\)，我们显然可以将这条边染色为 \\(ca\\)。 否则我们将这条边染色为 \\(ca\\)，然后尝试调整。 染色为 \\(ca\\) 之后，点 \\(v\\) 产生冲突，我们将原来为 \\(ca\\) 的边调整为 \\(cb\\)，这样又会使得 \\(v\\) 原来 \\(ca\\) 颜色的边连向的点产生冲突，我们又将其 \\(cb\\) 边调整为 \\(ca\\)。类似于匈牙利算法，一直循环下去。 这样一定不会产生冲突。因为二分图不存在奇环。所以循环回到 \\(v\\) 时，是将一条颜色为 \\(cb\\) 的边调整为 \\(ca\\)，但是根据假设，这样的边不存在。 Code","link":"/2021/09/01/Codeforces%20Round%20591/"},{"title":"Codeforces Round #612","text":"Codeforces Round #612 A.Garland 题意：有一个长为 \\(n\\) 的排列，一些元素被替换成了 \\(0\\)。你需要补全这个排列，使得这个排列中奇偶性不同的相邻元素对数最少。 可以直接 dp，\\(f[i][s_0][s_1]\\) 表示前 \\(i\\) 个元素补全 \\(s_0\\) 个偶数元素，\\(s_1\\) 个奇数元素后的最小代价。 B.Numbers on Tree 题意：给定一棵树，每个节点有一个权值 \\(c_i\\)。你需要给每个节点赋一个权值 \\(a_i\\)。使得对于每个节点 \\(i\\)，满足 \\(j\\) 在子树 \\(i\\) 内且 \\(a_j &lt; a_i\\) 的 \\(j\\) 个数恰好为 \\(c_i\\)。 如果有解，那么我们可以将 \\(1-n\\) 赋到每个节点上。 我们记 \\(solve(u,S)\\) 表示将集合 \\(S\\) 中的数赋给子树 \\(u\\)。那么如果 \\(c_u = k\\)，我们就给 \\(u\\) 赋第 \\(k + 1\\) 小的元素。然后从 \\(S\\) 中去掉我们选择的元素，将剩下的赋值给它的子树。 C.Madhouse 本题是一道交互题。 题意：有一个长为 \\(n\\) 的字符串。你可以给出 \\([l,r]\\)，询问 \\([l,r]\\) 内的所有子串。子串的顺序，以及子串内部字母的顺序都会被打乱。 用不超过 \\(3\\) 次询问确定这个字符串，并且询问的所有子串的长度总和不超过 \\(\\lceil 0.777(n+1)^2\\rceil\\)。 在简单版本中，所有子串的长度总和不超过 \\((n+1)^2\\) 简单版本，我们询问 \\([1,n]\\) 内的子串，再询问 \\([2,n]\\) 内的子串，两者做差，我们就可以确定原字符串。 在困难版本中，我们先套用简单版本的做法，确定 \\([1,\\lceil \\frac{n}{2}\\rceil]\\) 部分。之后我们再询问 \\([1,n]\\) 内的所有子串。 把所有长度为 \\(2\\) 的子串重叠在一起，那么 \\(1,n\\) 两个位置只贡献了一次。由于我们已经知道位置 \\(1\\) 的字符，所以我们可以确定位置 \\(n\\) 上的字符。类似的，我们可以确定整个字符串。 D.LCC 题意：一条无限长的管道中有 \\(n\\) 个粒子，第 \\(i\\) 个粒子的位置为 \\(x_i\\)，\\(\\forall i\\in[1,n),x_i&lt;x_{i+1}\\)。 实验开始时，第 \\(i\\) 个粒子会获得 \\(v_i\\) 的初速度，有 \\(\\frac{p_i}{100}\\) 的概率向右，有 \\(1-\\frac{p_i}{100}\\) 的概率向左。 任意两个粒子移动到相同位置的时候，实验停止。特别地，如果没有发生任何碰撞我们认为实验的时间为 \\(0\\)。求一次实验期望耗费的时间。 首先碰撞只会发生在相邻粒子之间。我们预处理出所有可能的碰撞（\\(O(3n)\\) 种），将它们按照时间从小到大排序。 我们已经知道了时间，我们只需要求出概率就可以算出期望了。第 \\(i\\) 个碰撞发生的概率，等于钦定前 \\(i - 1\\) 个碰撞不发生的概率减去钦定前 \\(i\\) 个碰撞不发生的概率。 我们钦定一种碰撞不发生，等价于禁止了某对相邻粒子处于某种特定状态。 我们记 \\(f[l][r][a][b]\\) 表示粒子 \\([l,r]\\)，粒子 \\(l\\) 的方向为 \\(a\\)，粒子 \\(r\\) 的方向为 \\(b\\)，且这些粒子状态合法的概率。 转移类似于矩阵乘法。 \\[ f[l][r][a][b]=\\sum_{x}\\sum_yf[l][mid][a][x]\\cdot f[mid+1][r][y][b] \\] 能转移，当且仅当粒子 \\(mid\\) 方向为 \\(x\\)，粒子 \\(mid + 1\\) 方向为 \\(y\\) 没有被禁止。 可以使用线段树维护，每次禁止一对相邻粒子相当于执行一次单点修改。","link":"/2021/06/09/Codeforces%20Round%20612/"},{"title":"Codeforces Round #621","text":"Codeforces Round #621 A.Cow and Haybales 题意：给定长为 \\(n\\) 的序列 \\(a\\)，每次你可以选定 \\(i,j \\quad |i-j|=1,a_i&gt;0\\)，令 \\(a_i \\leftarrow a_i-1,a_j \\leftarrow a_j+1\\)。你可以进行不超过 \\(d\\) 次操作，使得 \\(a_1\\) 尽量大。 直接贪心。 B.Cow and Friend 题意：给定长为 \\(n\\) 的序列 \\(a\\)，每次你可以从二维平面上一个位置移动到离它欧几里得距离恰为 \\(a_i\\) 的另一个位置。求最少需要几次移动可以从 \\((0,0)\\) 移动到 \\((x,0)\\)。 设 \\(\\max a_i=mx\\)，如果 \\(mx = x\\) 那么只需要 \\(1\\) 次。如果 \\(mx &gt; x\\) 那么需要 \\(2\\) 次。否则需要 \\(\\lceil \\frac{x}{mx}\\rceil\\) 次。 C.Cow and Message 题意：给定一个字符串 \\(s\\)。一个字符串 \\(t\\) 是隐藏的，当且仅当 \\(t\\) 是 \\(s\\) 的子序列并且 \\(t\\) 在 \\(s\\) 中出现的下标构成了一个等差数列（公差必须为正整数）。求在 \\(s\\) 中出现次数最多的隐藏字符串的出现次数。 首先这个字符串只可能长为 \\(1,2\\)。直接枚举起始端点，根据后缀每个字母出现次数算一下就行了。 D.Cow and Fields 题意：给定一个 \\(n\\) 个点 \\(m\\) 条边的无向连通图。一个顶点集 \\(S\\)。你需要选择两个顶点 \\(u,v \\quad u\\neq v,u \\in S,v \\in S\\)，并添加一条边 \\((u,v)\\)。求加边后 \\(1\\) 到 \\(n\\) 的最短路的最大值。 考虑贪心。如果原图中存在边 \\((u,v) \\quad u \\in S,v\\in S\\)，那么我们添加一条重边，这样不会改变最短路。否则我们将顶点集按照到 \\(s\\) 最短路升序为第一关键字，到 \\(t\\) 最短路降序为第二关键字进行排序。然后枚举相邻点连边。 E.Cow and Treats 题意：有 \\(n\\) 棵排成一行的草，第 \\(i\\) 棵草有甜味 \\(s_i\\)。有 \\(m\\) 头奶牛，第 \\(i\\) 头有喜欢的甜味 \\(f_i\\) 和饥饿值 \\(h_i\\)。在这 \\(m\\) 头奶牛中选取两个不相交子集，分别在这行草的左侧和右侧排成一列。你可以任意指定奶牛吃草的顺序。奶牛吃草的方式如下： 一头奶牛吃草时，它会径直从一端走向另一端，一路上把 \\(s_i=f\\) 的草吃掉。 当一头奶牛吃了恰好 \\(h_i\\) 棵草，它会立即在原地停止不动并睡觉。 如果一头奶牛遇到了另一头睡着的奶牛，或者它走到了整行草的末尾都没有吃饱，那么它就会变得沮丧。 不能让任意一头奶牛沮丧。你不必选取所有奶牛。求睡着的奶牛数量的最大值，以及保证睡着的奶牛数量最大的前提下的方案数。 首先把奶牛按照喜欢的甜味进行分组，这样每组内最多选出 \\(2\\) 头牛。再预处理出它从左往右和从右往左，吃饱需要走多远。枚举从左往右不能越过哪里，再对每组考虑，就可以 \\(O(nm)\\) 求出睡着的奶牛数量的最大值。 这样计算方案会算重，由于不存在 \\(f,h\\) 均相同的两头奶牛，因此我们可以钦定有一头奶牛从左往右走到了哪里。求最大值的时候我们已经求出了哪些分界线是可行的，这样我们就知道每组内会选出几头奶牛，讨论一下即可。 需要较为精细的实现。 F.Cow and Vacation 题意：给定一棵 \\(n\\) 个点的树，上面有 \\(r\\) 个可以休息的点。从任意点出发，在不休息的情况下最多走 \\(k\\) 条边。给定 \\(q\\) 次询问，求能否从 \\(u_i\\) 移动到 \\(v_i\\)。 我们把每条边拆开变成两条边，这样可以省去繁琐的细节判断。把所有休息点都丢进队列进行 \\(k\\) 轮 bfs，如果两块边界相遇我们就将这两个块合并。可以用并查集来维护。 查询操作，我们先判掉 \\(u_i\\) 可以直接走到 \\(v_i\\) 的情况。之后我们将 \\(u\\) 朝 \\(v\\) 走 \\(k\\) 步，\\(v\\) 朝 \\(u\\) 走 \\(k\\) 步，查询它们是否在一个连通块内就行了。上述操作可以通过倍增来完成。 G.Cow and Exercise 后补。","link":"/2021/05/04/Codeforces%20Round%20621/"},{"title":"Codeforces Round #637","text":"Codeforces Round #637 A.Nastya and Strange Generator 题意：有一个按照如下方法随机生成排列 \\(p\\) 的生成器： 定义 \\(r_j\\) 为 \\(j\\) 右侧（包括 \\(j\\) ）第一个没有被标记的位置， \\(count_j\\) 表示满足 \\(r_i=j\\) 的 \\(i\\) 的个数。 每一轮选择 \\(count\\) 值最大的位置 \\(i\\)，将 \\(p_i \\leftarrow\\) 已经被标记的位置的数量 \\(+1\\)。有多个相同位置可任意选择。 现在给你一个排列，求这个排列有没有可能是上面的生成器生成的。 如果某一轮在一个位置填了数，那么接下来必须填满以它开头的后缀。 B.Nastya and Scoreboard 题意：有 \\(n\\) 个如下图所示的灯组原件，组成了一个计分板。 在这 \\(n\\) 个灯组原件中，有一些灯管保持常亮。求再点亮恰好 \\(k\\) 个灯管，可以组成的最大的数。 设 \\(ok[p][k]\\) 表示以 \\(p\\) 开头的后缀，再点亮恰好 \\(k\\) 个灯管能否组成一个合法的数。转移用位运算很容易实现。 求最大的数利用 dp 出来的 \\(ok\\) 数组，直接从高位贪心就行了。 C.Nastya and Unexpected Guest 题意：马路可以视作一个 \\([0,n]\\) 的数轴。马路上有 \\(m\\) 个安全岛，坐标为 \\(d_1,d_2,\\cdots,d_m,d_i\\in \\mathbb{N}\\)。位置 \\(0\\) 和 \\(n\\) 都有安全岛。每一秒你可以从位置 \\(x\\) 移动到 \\(x \\pm 1\\)，但不能移出马路。你只有到达安全岛才能改变你的移动方向。有一个红绿灯，绿灯时间为 \\(g\\) 秒，红灯时间为 \\(r\\) 秒。你在绿灯时间内必须连续不断地移动，在红灯时间内必须在某个安全岛停留。在时刻 \\(0\\) 你到达了位置 \\(0\\)，此时红灯刚刚变为绿灯，求你到达位置 \\(n\\) 的最短时间。 设 \\(f[p][t]\\) 表示你在时刻 \\(tim\\) 到达安全岛 \\(p\\) 的最短时间，其中在时刻 \\(tim\\)，一个周期开始了 \\(t\\) 秒。（时刻 \\(0-(g-1)\\) 是绿灯，\\(g-(g+r-1)\\) 是红灯） 这样点数是 \\(mg \\leq 10^7\\)。直接跑最短路是不行的。 考虑过马路的过程，如果可以直接从位置 \\(0\\) 走到位置 \\(n\\) 那肯定直接走。否则在中间某个安全岛度过一轮红绿灯，又相当于从位置 \\(d_x\\) 走到位置 \\(n\\)。因此我们只用关心 \\(f[p][0]\\) 的值，剩下一段一定是直接走到位置 \\(n\\)。 我们令 \\(f[p][t]\\) 表示在时刻 \\(t\\) 到达安全岛 \\(p\\) 至少需要经过几轮红绿灯。 那么： \\(f[u][t]\\rightarrow f[v][t'] \\quad t' \\neq g\\) \\(f[u][t]+1\\rightarrow f[v][0] \\quad t'=g\\) （以上均默认转移合法） 这样就可以用 01-BFS 做到 \\(mg\\) 的复杂度。（边权 \\(0\\) 入队头，边权 \\(1\\) 入队尾，相当于把边权 \\(0\\) 的连通块缩点）。 D.Nastya and Time Machine 题意：给定一棵有 \\(n\\) 个点的树，通过每条边需要 \\(1\\) 秒。你的位置可以用 \\((v,t)\\) 表示，在时刻 \\(t\\) 你在顶点 \\(v\\)。你可以进行如下操作： 时间回溯，走到位置 \\((v,t') \\quad t'&lt;t\\)。 沿着树上的边 \\((u,v)\\) 走到位置 \\((u,t+1)\\)。 你不能经过同一个位置两次（顶点和时刻都相同）。在时刻 \\(0\\) 你在根节点，求一条经过所有点至少一次并回到根的路径 $(v_1,t_1),(v_2,t_2),$，使得 \\(\\max t_i\\) 最小。 首先记 \\(\\max deg[u]=T\\)，那么答案为 \\(T\\)。这是一个显然的下界，可以通过如下构造方案取到： 记 \\(solve(u,tim,tag)\\) 表示我们构造一条在时刻 \\(tim\\) 到达节点 \\(u\\) ，遍历它的整棵子树，在时刻 \\(tag\\) 回到点 \\(u\\) 的路径。 进入 \\(u\\) 时记录答案 \\((u,tim)\\)。遍历 \\(u\\) 的所有儿子 \\(v\\)，\\(solve(v,tim+1,tim)\\)，回溯到 \\(u\\) 时记录 \\((u,tim + 1)\\)，然后令 \\((u,tim) \\leftarrow (u,tim + 1)\\)。如果进入 \\(v\\) 这棵子树之前点 \\(u\\) 就有 \\(tim = T\\)，那么进行时间回溯，记录答案，使得遍历完成之后的时刻恰好是 \\(tag\\)。利用已经遍历的儿子数量这是非常好计算的。 如果遍历完所有儿子之后 \\(tim \\neq tag\\)，时间回溯，记录答案。 E.Nastya and Bees 错题？ F.Nastya and CBS 后补","link":"/2021/04/25/Codeforces%20Round%20637/"},{"title":"Codeforces Round #635","text":"Codeforces Round #635 A.Linova and Kingdom 题意：给定一棵有 \\(n\\) 个节点的树，\\(1\\) 为根节点。你需要选择恰好 \\(k\\) 个节点将其设置为工业城市，其余城市为旅游城市。对于一个工业城市，定义它的幸福值为它到根的路径上的旅游城市数量。求所有工业城市的幸福值之和的最大值。 显然选一个点之前我们会先选完它子树内的所有点，因此每个点 \\(u\\) 对答案的贡献为 \\(dep[u] - (siz[u] - 1)\\) 其中 \\(dep[u]\\) 表示根到 \\(u\\) 点路径上的边的条数。直接贪心选前 \\(k\\) 大就可以了 B.Xenia and Colorful Gems 题意：给定三个正整数序列 \\(r,g,b\\)，长度分别为 \\(n_r,n_g,n_b\\)。在三个序列中各取一个整数 \\(x,y,z\\)，使得 \\((x-y)^2+(y-z)^2+(z-x)^2\\) 最小。 考虑贪心，我们在 \\(r\\) 内枚举 \\(x\\)，在 \\(g\\) 中找到其后继 \\(y\\)，在 \\(b\\) 中找到其前驱 \\(z\\)。可能会漏解，我们枚举 \\(r,g,b\\) 的排列顺序，共 \\(6\\) 种情况。 C.Kaavi and Magic Spell 题意：给定一个长为 \\(n\\) 的字符串 \\(S\\) 和一个长为 \\(m\\) 的字符串 \\(T\\)，每次可以删去 \\(S\\) 的第一个字符，将其放到一个初始为空的字符串 \\(A\\) 的首部或尾部，求有多少种不同的方法使得最后 \\(T\\) 是 \\(A\\) 的前缀。 首先我们只需要匹配前缀，且有 \\(|T|\\leq|S|\\)，那么我们直接在 \\(T\\) 后面补通配符使得 \\(|S|=|T|\\)。 记 \\(f[l][r]\\) 表示在 \\(S\\) 中操作长度为 \\(r-l+1\\) 的前缀匹配 \\(T[l,r]\\) 的方案数，转移是非常容易的。 最后答案为 \\(2\\sum_{i=m}^{n}f[1][i]\\)。 D.Yui and Mahjong Set 本题是一道交互题 题意：有一个由 \\(n\\) 种麻将牌组成的可重集 \\(S\\)，牌的编号为 \\(1-n\\)。保证初始集合内每种牌不超过 \\(n\\) 张。开始时交互库会告诉你 \\(n\\)，以及初始集合内刻子和顺子的数量。如\\(\\{1,1,2,2,3\\}\\) 有 \\(4\\) 个顺子 \\(\\{1,2,3\\}\\)。现在你可以进行至多 \\(n\\) 次查询操作：将一张编号为 \\(x\\) 的牌插入集合 \\(S\\)。交互库会告诉你插入后刻子和顺子的数量。求出初始集合内每张牌的数量。 我们按照 \\(n-1,n-2,\\cdots,3,1,2,1\\) 的顺序放牌。记初始集合内牌 \\(i\\) 的数量为 \\(a_i\\)。 那么第一次放 \\(1\\)，顺子增加量为 \\(a_2(a_3+1)\\)，第二次放 \\(1\\)，顺子增加量为 \\((a_2+1)(a_3+1)\\)，可以推出 \\(a_3\\)，从而推出 \\(a_2\\)。我们放了 \\(2\\) 次 \\(1\\)，第一次刻子增加量 \\(\\frac{a_1(a_1-1)}{2}\\)，第二次刻子增加量 \\(\\frac{(a_1+1)a_1}{2}\\)，所以可以推出 \\(a_1\\)。 之后顺着推过去就可以了。","link":"/2021/04/26/Codeforces%20Round%20635/"},{"title":"Codeforces Round #658","text":"Codeforces Round #658 A.Prefix Flip 题意：给定两个长均为 \\(n\\) 的 \\(\\texttt{01}\\) 字符串 \\(S,T\\)。定义一次操作为：选定 \\(S\\) 的一个前缀，将其中的 \\(\\texttt{0}\\) 和 \\(\\texttt{1}\\) 翻转，并且元素的位置翻转。比如 \\(\\texttt{011}\\) 翻转为 \\(\\texttt{001}\\)。使用不超过 \\(2n\\) 次操作将 \\(S\\) 变为 \\(T\\)。 首先用 \\(n\\) 次操作把 \\(S\\) 变为全 \\(\\texttt{0}\\) 或者全 \\(\\texttt{1}\\)。之后我们倒着遍历 \\(S\\)，再用 \\(n\\) 次操作将 \\(S\\) 变为 \\(T\\)。 Easy Version：限制放宽到 \\(3n\\)，我们可以用 \\(3\\) 次操作翻转某一位。 B.Unmerge 题意：给定一个长为 \\(2n\\) 的排列，求它是否可以由两个长度为 \\(n\\) 的序列通过归并排序的方式合并得来。比如 \\([2,3,1,4]=merge([3,1],[2,4])\\) 暴力设状态 \\(f[a][b][len]\\) 表示第一个序列的首元素为 \\(a\\)，第二个序列的首元素为 \\(b\\)，第一个序列的长度为 \\(len\\)，我们能否合并出原序列的对应后缀。这样是 \\(n^3\\) 的。 我们可以固定 \\(a\\) 表示后缀的首元素 ，这样要使得转移的可能性尽可能大，我们就要在 \\(a,len\\) 一定的条件下尽可能用最大的 \\(b\\) 转移。也就是状态变成了 \\(f[a][len]=\\max b\\)（相当于原来每个状态只记录了可行性，由于可以转移贪心所以把最优选择丢给值来记录） C.Mastermind 题意：给定一个长为 \\(n\\) 的序列 \\(a\\)，值域 \\([1,n+1]\\)。给定 \\(x,y\\)，构造一个序列 \\(b\\)，满足 \\(b\\) 和 \\(a\\) 有 \\(x\\) 个位置上的元素一样。有 \\(y\\) 个元素和 \\(a\\) 里面的元素一样。 由于值域 \\(n + 1\\)，所以我们一定可以找到一个没有在 \\(a\\) 里面出现过的元素，记为 \\(ghost\\)。这会给我们带来极大便利。 假设我们已经选定了这 \\(x\\) 个位置，再对剩下的 \\(n - x\\) 个元素进行重排，多余的元素我们直接填 \\(ghost\\)。记剩下的元素的众数的出现次数为 \\(f\\)，那么无论如何都有 \\(max(0,2f-(n-x))\\) 个位置会和 \\(a\\) 一样（冲突）。 要使得冲突的位置个数达到最小值，我们将剩下的元素重排成若干个连续段，再旋转 \\(\\lfloor \\frac{n-x}{2} \\rfloor\\) 。这样我们就找到了值之间的对应关系。一路填过去就行了。非 \\(ghost\\) 的选不够 \\(y -x\\) 个则无解。 怎么选取这 \\(x\\) 个位置使得我们有解的概率尽可能大？显然我们每次贪心选出现次数最多的，这样可以使 \\(f\\) 尽量小。拿个堆维护一下就可以了。","link":"/2021/04/20/Codeforces%20Round%20658/"},{"title":"Codeforces Round #679","text":"Codeforces Round #679 A.Perform Easily 题意：给定一个长度为 \\(6\\) 的序列 \\(a\\)，以及一个长度为 \\(n\\) 的序列 \\(b\\)。你需要将 \\(b_i\\) 减去 \\(a\\) 中任意一个数，要求处理后的序列 \\(b\\) 的最大值减最小值尽可能小。 考虑将 \\(b\\) 排序，然后枚举 \\(i,j\\)，相当于我们钦定 \\(b_i-a_j\\) 是最小值。最大值直接二分。check 的话考虑对于每个数，让它在满足二分最大值限制的条件下减去的尽量少，如果小于枚举的最小值则无解。 B.Shurikens 题意：有一家商店出售 \\(n\\) 个手办，第 \\(i\\) 个手办可以用 \\(i\\) 元买到。 现在有 \\(2n\\) 次操作： \\(\\texttt{+}\\) 表示在柜台上摆放一个手办 \\(\\texttt{- x}\\) 表示被买走了一个 \\(x\\) 元的手办。如果柜台上有很多个手办，人们只会买最便宜那个。 根据这 \\(2n\\) 次操作构造一种摆放手办的顺序或者判断无解。 我们维护摆放序列中还没有填数的位置。每次将当前数填到最后一个位置。最后 check 一下。 证明可以从决策包容性角度感性理解。 洛谷上给出了另一种解法，处理这种信息不对称的题目我们可以倒着跑。 维护一个小根堆，表示柜台上的手办。 遇到 \\(\\texttt{-}\\)，这个时候应该是堆中出现了一个更小的数。我们直接判断堆顶和新数的大小关系。 遇到 \\(\\texttt{+}\\)，说明我们可以从堆里面随便拿出一个数。要使得上面的操作合法的可能性尽可能大，我们取走堆顶。如果无数可取那么也是非法的。 C.Solo mid Oracle 题意：敌人有一个初始生命。你可以发起进攻，使得敌人的生命值 \\(-a\\)。如果你在 \\(t\\) 时刻发起进攻 \\(t+1,t+2,\\cdots,t+c\\) 时刻敌人会恢复生命 \\(b\\)。如果你在 \\(t\\) 时刻发起进攻，下一次进攻不早于 \\(t + d\\) 时刻。敌人生命值减少和恢复在同一时刻进行。如果在任意时刻敌人的生命值 \\(\\leq 0\\)，你赢了。问敌人最大有多少初始生命时，你可以获胜。或者答案为无穷大。 首先，如果 \\(a &gt; b \\times c\\) 那么答案为无穷大。 否则，这启示我们，如果在 \\(0\\) 时刻发起攻击，在 \\(\\lceil \\frac{a}{b}\\rceil\\) 时刻 \\(0\\) 时刻的攻击造成的贡献就会被抵消。所以最大伤害总和一定出现在 \\(0-\\lfloor \\frac{a-1}{b}\\rfloor\\) 时刻。 继续考虑，如果某一段时间只是在回血而没有攻击，那么还不如取最后一次攻击。 所以最大伤害一定会出现在第 \\(\\lfloor \\frac{\\lfloor \\frac{a-1}{b} \\rfloor}{d} \\rfloor =\\lfloor \\frac{a-1}{bd} \\rfloor\\) 次攻击。 D.Roads and Ramen 题意：给定一棵树，每条边都有标记 \\(0\\) 或 \\(1\\)。现在有 \\(m\\) 次操作，每次操作将第 \\(id\\) 条边的标记异或 \\(1\\)。求每次操作后树上最长的有偶数个1的简单路径包含多少条边。 首先我们记每个点的颜色为它到根路径上的边的权值的异或。那么变成选择一条两端点颜色相同的简单路径，让它尽量长。而对边的修改也变成了对子树内点的修改。 关键结论：到一个点距离最远的那个点，一定是直径的端点之一。所以我们直接找一条直径出来，以它的两个端点为根建两棵树。我们要支持子树内点异或一个值，查询离根最远的权值为 \\(0\\) 的点到根的距离。 直接 dfs 序，然后线段树维护。","link":"/2021/04/14/Codeforces%20Round%20679/"},{"title":"Codeforces Round #680","text":"Codeforces Round #680 A.Division 题意：给定两个数 \\(p,q\\)，求最大的整数 \\(x\\)，使得 \\(x \\mid p\\)，且 \\(q \\nmid x\\) 首先判断一下，如果 \\(q \\nmid p\\) 的话，\\(x = p\\) 否则我们分解考虑 \\(q\\) 的所有质因子 \\(fac\\)，对于每个 \\(fac\\)，我们不断将 \\(p \\leftarrow \\frac{p}{fac}\\)，直到 \\(q \\nmid p\\)，在所有可能情况里面取最大的 \\(p\\)。 B.Divide and Sum 题意：给定一个长度为 \\(2n\\) 的数列 \\(a\\)，将 \\(a\\) 中的数任意分成两串长度为 \\(n\\) 的数列 \\(p\\) 和 \\(q\\)。我们按照非递减的顺序对 \\(p\\) 排序，按照非递增的顺序对 \\(q\\) 排序。然后我们定义 \\(f(p,q)=\\sum_{i=1}^{n}|p_i-q_i|\\)。求 \\(\\sum f(p,q)\\) 关键在于拆绝对值符号： \\(\\sum_{i=1}^n|p_i-q_i|=\\sum_{i=1}^n\\max(p_i,q_i)-\\min(p_i,q_i)\\) 在任意一种划分中，\\(\\forall i \\quad p_i,q_i\\) 分别属于前 \\(n\\) 大的数或者前 \\(n\\) 小的数。 否则，假设我们有 \\(p_i,q_i\\) 同为前 \\(n\\) 大，那么就一定有 \\(p_j,q_j\\) 同为前 \\(n\\) 小。 那么有 \\((p_i-p_j)(q_i-q_j) \\geq 0\\)，也就是 \\(p_i,p_j\\) 和 \\(q_i,q_j\\) 的大小关系相同，不合题意。 那么对于所有划分方案，\\(f(p,q)\\) 都是相同的。 C.Team-Building 题意：给定一张 \\(n\\) 个点 \\(m\\) 条边的二分图，没有重边自环。每个点都有一个颜色，共有 \\(k\\) 种颜色，可能有一些颜色没有点。求选出两种颜色的点，导出子图是二分图的方案数。 先转换一下，求出导出子图不是二分图的方案数。 设选定颜色 \\((a,b)\\) 之后导出子图不是二分图，那么原图中一定有至少一条边，两端点颜色分别为 \\(a,b\\)，也就是我们只需要枚举 \\(m\\) 条边就可以了。 判定导出子图是不是二分图考虑扩展域并查集。我们先将两端点颜色相同的边加入图中，每次加入所有两端点颜色分别为 \\(a,b\\) 的边，按秩合并支持撤销即可。","link":"/2021/04/14/Codeforces%20Round%20680/"},{"title":"Codeforces Round #691","text":"Codeforces Round #691 A.Row GCD 题意：给定长为 \\(n\\) 的序列 \\(a\\)，长为 \\(m\\) 的序列 \\(b\\)。 现在 \\(\\forall j \\in[1,m]\\)，求出 \\(\\gcd(a_1+b_j,a_2+b_j,\\cdots,a_n+b_j)\\)。 根据更相减损术，我们要求的东西等于 \\(\\gcd(a_1 - a_n,a_2-a_n,\\cdots,a_n+b_j)\\)。 前 \\(n - 1\\) 个都是常数预处理一下就行了。 B.Glass Half Spilled 题意：有 \\(n\\) 杯水，第 \\(i\\) 杯容量为 \\(a_i\\) 单位，初始装有 \\(b_i\\) 单位的水。 现在你可以进行若干次操作，每次选择杯子 \\(i,j\\)，从有 \\(c_i\\) 单位水的杯子 \\(i\\) 向有 \\(c_j\\) 单位水的杯子 \\(j\\) 倒 \\(x\\) 单位水，那么会洒出去 \\(\\frac{x}{2}\\) 单位水。杯子 \\(i\\) 的水量变成 \\(c_i - x\\)，杯子 \\(j\\) 的水量变成 \\(min(a_j,c_j+\\frac{x}{2})\\) 现在 \\(\\forall p \\in[1,n]\\)，求出进行若干次操作之后，选取 \\(p\\) 个杯子能够得到的水量的最大值。 我们记总水量为 \\(S\\)，那么我们选一个杯子集合能够得到的最大水量 \\(\\min(\\sum c,\\frac{1}{2}S+\\frac{1}{2}\\sum b)\\) 直接考虑 dp，\\(f[i][j][k]\\)，前 \\(i\\) 杯水里面选 \\(j\\) 杯水，\\(\\sum c=k\\) 时，能够得到的 \\(\\sum b\\) 的最大值。 C.Latin Square 题意：维护一个 \\(n \\times n\\) 的矩阵，每行每列都是一个 \\(1-n\\) 的排列。有 \\(m\\) 次操作： 将每行向左循环移动一格 将每行向右循环移动一格 将每列向上循环移动一格 将每列向下循环移动一格 将每行变成原来的逆排列 将每列变成原来的逆排列 关键在于转变对矩阵的看待方式。我们将矩阵看待为 \\(n\\times n\\) 个三元组 \\((i,j,v)\\)，表示第 \\(i\\) 行第 \\(j\\) 列有元素 \\(v\\)。 那么前四种操作相当于对前两个维度之一 \\(+1\\) 或者 \\(-1\\)。 后两种操作相当于交换所有三元组的 \\(i,v\\) 或者 \\(j,v\\)。 维护一下维度间的映射关系就可以了。 D.Flip and Reverse 题意：给定 \\(\\texttt{01}\\) 字符串 \\(s\\)，你可以进行若干次操作。对于每一次操作： 选择字符串 \\(s\\) 的一个子串，要求这个字符串必须包含同样数量的 \\(\\texttt{0}\\) 和 \\(\\texttt{1}\\)。 把该子串的所有字符转换,即所有字符 \\(\\texttt{0}\\) 换为 \\(\\texttt{1}\\),字符 \\(\\texttt{1}\\) 换为 \\(\\texttt{0}\\)。 把选中的子串反转。 求经过若干次操作后字典序最小的字符串 我们把 \\(\\texttt{0}\\) 当做向左走，把 \\(\\texttt{1}\\) 当做向右走。那么我们就可以得到一张图，一个欧拉回路就对应一个 \\(\\texttt{01}\\) 数量相等的字符串。而我们对它进行的操作就相当于将环上所有边翻转。 而翻转一个环（或者一个欧拉回路）之后，图是不会改变的。因此能变换出的所有字符串，它们生成的图都是一样的。所以我们直接走字典序最小的欧拉路就可以了。","link":"/2021/04/09/Codeforces%20Round%20691/"},{"title":"Codeforces Round #692","text":"Codeforces Round #692 A.Peaceful Rooks 题意：给定一个 \\(n \\times n\\) 的棋盘，上面有 \\(m\\) 个车。初始状态没有两个车互相攻击。每一步操作你可以移动一个车，需要保证移动之后仍然没有两个车互相攻击。求最少需要移动多少次可以将每个棋子位于棋盘的主对角线上。 首先已经在对角线上面的棋子我们是不用移动的。不在对角线上面的棋子我们至少要移动一次。之后我们将必须要移动的棋子的行编号和列编号之间连一条无向边。对于每一个环，我们至少还要多移动一次。可以用并查集维护。 B.Grime Zoo 题意：给定一个字符串 \\(s\\)，字符集为 $\\texttt{{0,1,?}}$ ，以及参数 \\(x,y\\)。你需要将所有 \\(\\texttt{?}\\) 替换为 \\(\\texttt{0}\\) 或 \\(\\texttt{1}\\)。 定义这个字符串的代价为：\\(\\texttt{01}\\) 子序列的数量 \\(\\times\\ x \\ + \\ \\)\\(\\texttt{10}\\) 子序列的数量 \\(\\times\\;y\\) 求字符串代价的最小值。 讨论一波发现，答案字符串一定是前缀问号填 \\(\\texttt{0}\\)，后缀填 \\(\\texttt{1}\\)，或者前缀问号填 \\(\\texttt{1}\\)，后缀填 \\(\\texttt{0}\\)。 C.Poman Numbers 题意：定义一个对小写字符的函数 \\(pos(x)=x-a\\)，如 \\(pos('a')=0\\)。 定义作用于字符串的函数 \\(f\\)： \\(f(S) = \\begin{cases} 2^{pos(S[1])} \\quad |S|=1 \\\\ -f(S[1,m])+f(S[m+1,|S|]) \\quad \\text{otherwise}\\end{cases}\\) \\(m\\) 自己任意指定。 给定一个小写字符串 \\(S\\)，长度为 \\(n\\)。询问能不能通过构造每一步中合适的 \\(m\\)，使得 \\(f(1,n)=T\\) 考虑每个位置最终对答案产生的贡献。符号是 \\(+,-,+,-,\\cdots,+\\)。也就是划分为若干段，最后一段符号为 \\(+\\)，相邻段符号不同。 这个等价于最后一个位置符号为 \\(+\\)，倒数第二个位置符号为 \\(-\\)。其余位置任意指定，能不能拼凑出 \\(T\\)。 我们将任意指定的位置全部都指定为 \\(-\\)，问题变成能不能从一个集合里面选出若干个数，使得它们的和为 \\(T\\)。 通过背包来做无法承受，注意到集合的特殊性。里面所有的数都是 \\(2\\) 的整次幂。因此我们从大到小贪心，能选就选。 D.The Thorny Path 题意：给定一个长为 \\(n\\) 的排列 \\(P\\)，定义一次操作为交换排列中任意两个元素。求能得到的排列的所有置换环的大小的乘积的最大值，以及在乘积最大前提下的最小操作次数。 求最大乘积等价于给定一个正整数 \\(n\\)，把它拆分成若干个数的和，使得它们的积最大。OEIS-A000792 最大乘积一定形如 \\(3^x,2\\cdot 3^x,4 \\cdot 3^x\\) 因为 \\(6=2+2+2=3+3\\)，而 \\(3 \\times 3 &gt;2\\times 2 \\times 2\\) 求最小操作次数我们按照 \\(n \\bmod 3\\) 的余数分类讨论 \\(n \\bmod 3 = 0\\)：拆分方案唯一，直接把所有大小大于 \\(3\\) 的置换环拆开，剩下的 \\(1,2\\) 先合并，再 \\(1,2\\) 内部合并。 \\(n \\bmod 3 = 2\\)：拆分方案唯一，拆一堆 \\(3\\) 和一个 \\(2\\)。和上面差不多。 \\(n \\bmod 3 = 1\\)：拆分方案不唯一，有可能拆个 \\(4\\)，也有可能 \\(2\\times 2\\)，对应的合并方案也不唯一。大力分类讨论。智慧不足以讨论出哪种情况最优那就全部试一遍取最优值。 E.No Game No Life 题意：Alice 和 Bob 又双叒叕在玩游戏。 给定一个 \\(n\\) 个点 \\(m\\) 条边的 DAG，每个点初始有 \\(a_i\\) 个芯片。 游戏开始前，每一秒都会在图上发生如下操作：在 \\([1,n+1]\\) 范围内等概率选取一个整数 \\(v\\)。如果 \\(v \\leq n\\)，那么在 \\(v\\) 顶点添加一个芯片。否则 Alice 和 Bob 开始游戏。 游戏是有向图游戏，Alice 和 Bob 轮流操作，Alice 先手。定义一次操作为将图上某一个顶点的一个芯片沿着有向边移到另一个顶点上面。如果一个人不能操作就输掉了游戏。 在 Alice 和 Bob 都采取最优策略的情况下，求出 Alice 赢的概率。 首先求出每个点的 SG 函数值。因为SG 函数值不会超过 \\(\\sqrt{m}\\)，所以它们的异或不会超过 \\(512\\)。那么我们直接高斯消元求解就可以了。","link":"/2021/04/07/Codeforces%20Round%20692/"},{"title":"Codeforces Round #707","text":"Codeforces Round #707 A.Going Home 题意：给定长为 \\(n\\) 的序列 \\(a\\)，求出任意一组 \\(x,y,z,w\\)，满足： \\(x,y,z,w\\) 互不相同 \\(a_x+a_y=a_z+a_w\\) \\(n\\in[4,2\\times 10^5],a_i \\in[1,2.5\\times 10^6]\\) 两数之和不会超过 \\(5 \\times 10^6\\)，因此我们直接暴力就可以了。 B.Two chandeliers 题意：给定长度分别为 \\(n,m\\) 的两个整数序列 \\(a,b\\)，以及正整数 \\(k\\)，其中序列 \\(a,b\\) 都满足其中没有相同元素。且序列 \\(a\\) 和序列 \\(b\\) 不完全相同。 求最小的整数 \\(q\\) 满足 \\(\\sum_{i=1}^q[a_{((i - 1) \\mod n)+1} \\neq b_{((i - 1) \\mod m)+1}] = k\\) 关键在于 \\(a,b\\) 都满足其中没有相同元素，因此我们找相同的元素对就可以了。它们在 \\(lcm(n,m)\\) 轮内的贡献可以很快求出。剩下的部分可以线性求出。 C.Matrix Sorting 题意：给定两个 \\(n \\times m\\) 的矩阵 \\(A,B\\)，矩阵内的元素均为 \\([1,n]\\) 内的整数。 每一次操作，你可以选定某一列作为每一行的关键字，按照关键字从小到大的顺序将所有行进行稳定排序。构造一种方案将矩阵 \\(A\\) 变成矩阵 \\(B\\)，或者判断无解。 首先我们可以通过 hash 处理出 \\(B\\) 的每一行对应 \\(A\\) 的哪一行。如果没法完全对应那么是无解的。我们将对应关系记为 \\(p\\)。我们只需要让在 \\(p\\) 对应下，\\(A\\) 中相邻行之间的位置关系合法即可。（即 \\(A\\) 中第 \\(p_i\\) 行和第 \\(p_{i+1}\\) 行相邻） 我们倒着考虑操作序列，如果一个操作会让某一对行不合法，那么我们不能使用该操作。但是如果我们已经执行过让这些行配对均合法的操作，那么这个操作就没有限制了。 我们在矩阵 \\(A\\) 后添加第 \\(m + 1\\) 列，令 \\(A_{i,m+1}=i\\)（一开始相当于操作第 \\(m + 1\\) 列） 我们将 \\(A\\) 的每一列视作一个点，将在 \\(p\\) 对应下，\\(A\\) 中的相邻行也视作点。 我们考虑对某一列排序之后，对每一对相邻行的影响。 1.让这一对相邻行合法，我们从列向行连边。 2.让这一对相邻行不合法，我们从行向列连边。 3.不会改变这对相邻行的合法状态，我们不连边。 这样就转变为了一个类似于拓扑排序的东西。当一个列没有入度的时候，我们才能使用。当一对行的入度减少 \\(1\\) 的时候，就可以使用。我们看能否使用第 \\(m + 1\\) 列即可。最后倒序输出答案。 D.Tiles for Bathroom 后补","link":"/2021/04/07/Codeforces%20Round%20707/"},{"title":"Codeforces Round #716","text":"Codeforces Round #716 (Div. 2) A.Perfectly Imperfect Array 题意：给定一个长为 \\(n\\) 的序列，求是否有一个子序列满足其元素的积不是一个完全平方数。 如果原序列存在非完全平方数则有，否则没有。 B.AND 0, Sum Big 题意：给定 \\(n,k\\)，求满足以下条件的长为 \\(n\\) 的序列的个数。 值域 \\([0,2^k)\\) 所有元素位运算与的结果是 \\(0\\) 所有元素的和尽量大 按位考虑，每一位有且只有 \\(1\\) 个 \\(0\\)，所以答案为 \\(n^k\\)。 C.Product 1 Modulo N 题意：给定 \\(n\\)，在 \\([1,2,\\cdots,n-1]\\) 中选出最长的子序列，使得它们的积 \\(\\bmod n=1\\) 根据威尔逊定理，如果 \\(p\\) 是一个质数，那么有： \\((p-1)! \\equiv -1\\pmod p\\) 那么这题有个类似的结论： \\(\\prod_{gcd(x,n)=1,x&lt;n} x \\equiv \\pm 1 \\pmod n\\) 证明 D.Cut and Stick 题意：给定长为 \\(n\\) 的序列以及 \\(q\\) 次询问。每次询问一个区间 \\([l,r]\\)，求至少需要把这个区间分成多少个子序列，使得对于每个长为 \\(x\\) 的子序列，众数的出现次数不超过 \\(\\lceil \\frac{x}{2}\\rceil\\)。 对于询问给定的长为 \\(len\\) 的区间，我们记其众数出现次数为 \\(mx\\)。 那么如果 \\(mx \\leq \\lceil \\frac{len}{2}\\rceil\\) 我们不需要拆分这个区间 否则答案为 \\(2mx-len\\)（相当于所有的非众数和尽可能多的众数放在一个子序列，剩下的众数每个数一个子区间） 问题变成求区间众数出现次数： 大爷的字符串题 莫队。 [Violet]蒲公英 分块。 注意到我们只需要出现次数大于 \\(\\lceil \\frac{len}{2}\\rceil\\) 的众数，因此我们可以考虑随机化。每次在给定区间中随机一个数，查询它的出现次数。这个可以开若干个 vector 然后我们直接二分找。如果存在出现次数超过一半的数，那么我们一次就找到的概率大于 \\(\\frac{1}{2}\\)。因此错误率为 \\(\\frac{1}{2^k}\\)。 E.Baby Ehab's Hyper Apartment 本题为交互题。 题意：有一个 \\(n\\) 个点的竞赛图（\\(n \\leq 100\\)）。你可以询问交互库以下两种问题： 两点 \\(a,b\\) 之间的边的方向 给定 \\(x\\) 和点集 \\(S\\)，询问是否存在边 \\(x\\rightarrow v \\quad v \\in S\\) 之后你需要回答所有点对之间的连通性。第一种操作限制 \\(9n\\) 次，第二种操作限制 \\(2n\\) 次。 我们考虑求出一张新图，使得原图上面的连通性也可以在新图上面表示。 由于这张图是一张竞赛图，因此它一定存在哈密顿路。我们用类似归并排序的方式求哈密顿路。 假设我们已经求出了两条路径 \\(a,b\\) ，现在我们要将它们拼接起来。我们每次询问两条路径头之间的边的方向，然后把其中一个点接在新路径的末尾。这样会用掉 \\(nlogn\\) 次操作 \\(1\\)。 我们已经求出了哈密顿路，现在我们只关心返回的边。且对于一个点我们只关心返回最远的边。因此我们可以使用双指针。 之后跑一个 Floyd 传递闭包就可以了。","link":"/2021/04/19/Codeforces%20Round%20716/"},{"title":"Codeforces Round #721","text":"Codeforces Round #721 (Div. 2) A.And Then There Were K 题意：给定 \\(n\\)，求最大的 \\(k\\) 使得 \\(n\\) AND \\((n - 1)\\) AND \\((n - 2)\\) AND \\(\\cdots\\) AND \\(k = 0\\) \\(k = \\max\\{x\\mid x=2^p-1,x&lt;n\\}\\) B.Palindrome Game 题意：Alice 和 Bob 又双叒叕在玩游戏。给定一个长为 \\(n\\) 的 01 串，两人轮流操作，Alice 先手。每一轮，玩家可以选择将一个 0 变成 1，支付 \\(1\\) 的代价。如果当前串不是回文串，那么可以选择什么都不干，不需要花费代价。如果 Alice 这回合啥都没干那 Bob 的回合必须操作，反之亦然。字符串变为全 1 时游戏结束，总代价小的人获胜。 两人均按最优策略，求最终结果。Alice 赢，Bob 赢，或者平局。 简单版本初始字符串为回文串。 首先考虑简单版本。 记 0​ 的个数为 \\(cnt\\)。如果 \\(cnt\\bmod2=0\\)，那么 Bob 必胜。因为不管 Alice 选啥，Bob 都可以选对应的使得原串为回文串。当还剩两个 0，Alice 选择其中一个时，Bob 可以啥都不干从而逼 Alice 再选一个。 当 \\(cnt\\bmod 2 =1\\) 时，如果 \\(cnt = 1\\) 那么 Bob 胜。否则 Alice 胜。因为 Alice 可以选中间那个 0，然后对称操作。当还有两个 0 时用同样的方法让 Bob 全选。 首先操作的顺序是不会影响答案的。我们记没有配对的 0 的个数为 \\(need\\)。那么 Alice 可以让 Bob 把 \\(need\\) 个 0 全部选择从而建立优势。 如果 \\(need \\geq 2\\)，那么 Alice 必胜。因为她总是可以在不付出额外代价（甚至有优势）的情况下，把原串变成回文串。但是自己可以选择先手或者后手。 否则，如果 \\(cnt = 2,need = 1\\)，那么平局。其余情况 Alice 必胜。 C.Sequence Pair Weight 题意：序列 \\(a\\) 的权值为 \\((i,j) \\quad i &lt; j,a_i=a_j\\) 的对数。给定一个序列，求它的所有子段的权值和。 考虑一对 \\((i,j) \\quad i&lt;j,a_i=a_j\\) 对答案产生的贡献。为 \\(i(n-j+1)\\)。 可以分为两部分 \\(i(n+1)\\)，\\(-ij\\)。分别计算即可。 D.MEX Tree 题意：给定一棵 \\(n\\) 个点的树，节点编号 \\(0-(n-1)\\)。\\(\\forall k \\in [0,n]\\)，求出有多少条简单路径，路径上的点的编号的 \\(mex\\) 为 \\(k\\)。 直接算不好算我们考虑算后缀。即，我们从 \\(0-(n-1)\\) 枚举，使得 \\([0,i]\\) 内的点可以形成一条简单路径。那么所有包含这些点的简单路径，就是 \\(mex\\) 大于 \\(i\\) 的简单路径。 需要较为精细的实现。 E.Partition Game 题意：定义序列 \\(t\\) 的代价为：\\(cost(t)=\\sum_{x\\in set(t)}last(x)-first(x)\\)，\\(set(t)\\) 表示所有元素去重之后的结果，\\(last\\) 和 \\(first\\) 表示一个元素第一次和最后一次出现的位置。 给定一个序列，将它划分为 \\(k\\) 段，使得每一段的代价之和最小。 首先可以写出一个暴力 \\(dp\\)。记 \\(f[i][j]\\) 表示前 \\(j\\) 个位置划分为 \\(i\\) 段的最小代价和。 \\(f[i][j] = \\min\\{f[i-1][k]+cost[k+1][j]\\}\\) \\(cost[l][r]\\) 表示将 \\([l,r]\\) 划分到一段的代价。 考虑优化，将 \\(cost(t)\\) 拆开。即将 \\(last(x)-first(x)\\)，拆分为所有出现的位置减上一次出现的位置的和。预处理一个 \\(pre[i]\\) 表示位置 \\(i\\) 上的元素上一次在哪里出现，就可以用区间加区间 \\(\\min\\) 线段树做到 \\(O(nklogn)\\)。","link":"/2021/05/20/Codeforces%20Round%20721/"},{"title":"Good Bye 2019","text":"Good Bye 2019 A.Card Game 题意：有 \\(n\\) 张牌，编号为 \\(1-n\\)。其中 \\(k_1\\) 张属于 A，\\(k_2\\) 张属于 B。每回合两人各出一张牌，编号大的一方会得到这两张牌，直到一个人没有牌，有牌的一方获胜。求 A 是否有必胜策略。 显然每次贪心出最大的牌，如果牌 \\(n\\) 在 A 手里就必胜，否则必败。 B.Interesting Subarray 题意：给定一个长为 \\(n\\) 的序列，要求找出一段连续的子序列 \\(s\\)，满足 \\(\\max(s)-\\min(s)\\geq |S|\\)。 我们只需要检查相邻元素（即所有长为 \\(2\\) 的连续子序列）即可。 C.Make Good 题意：给定 \\(n\\) 个数，在其中插入最多 \\(3\\) 个数字，使得这些数字的总和等于异或的 \\(2\\) 倍。 记这 \\(n\\) 个数的和为 \\(sum\\)，异或和为 \\(xor\\)。 插入一个 \\(xor\\)，此时异或和为 \\(0\\)，算术和为 \\(xor + sum\\)。再插入一个 \\(xor + sum\\) 即可。 D.Strange Device 本题是一道交互题。 题意：有一个长为 \\(n\\) 的，两两不同的序列。每次你可以给出 \\(k\\) 个互不相同的位置，询问这 \\(k\\) 个位置上第 \\(m\\) 小的数的值以及下标。给定 \\(n,k\\)，用不超过 \\(n\\) 次询问求出 \\(m\\)。\\(k&lt;n\\)。 这个序列具体是什么并不重要，因此我们可以令 \\(n\\leftarrow k+1\\)。 \\(\\forall i\\in[1,n]\\)，我们询问除了 \\(i\\) 之外的所有位置。 有 \\(m\\) 次，交互库会返回第 \\(m + 1\\) 小的数。 有 \\(n-m\\) 次，交互库会返回第 \\(m\\) 小的数。 统计一下每个数返回的次数就行了。 E.Divide Points 题意：给定 \\(n\\) 个点，将它们两两连边，边长为欧几里得距离。将它们分为两个非空组。如果边的两个端点在同一组为黄色，不同组为蓝色。求一种分组方案，使得所有黄色的边和蓝色的边长度不同。即所有长度相同的边颜色相同。 将所有点按照 \\(x,y\\) 坐标的奇偶性分为四组。记为 \\(v[0][0],v[0][1],v[1][0],v[1][1]\\) 如果所有点都在一个组内，那么我们将所有点的 \\(x,y\\) 坐标除以 \\(2\\)。即我们将图像等比例放缩，因此新图的合法分组方案在旧图仍然合法。 现在至少有两个组非空。我们将点按照 \\(x+y\\) 的奇偶性分组。 如果所有点的 \\(x + y\\) 均为偶，那么我们取 \\(v[0][0]\\) 为一组。 类似的，如果所有点的 \\(x + y\\) 均为奇，我们取 \\(v[0][1]\\) 为一组。 否则我们取所有 \\(x+y\\) 为奇的点为一组。 F.Awesome Substrings 题意：给定一个长为 \\(n\\) 的 \\(\\texttt{01}\\) 串。求有多少个区间 \\([l,r]\\)，满足 \\(r-l+1\\) 是 \\([l,r]\\) 中 \\(\\texttt{1}\\) 的个数的倍数。 记 \\(sum\\) 表示前缀 \\(\\texttt{1}\\) 的个数。拆一下，限制条件等价于 \\(k(sum[r]-sum[l])=r-l\\)，即 \\(k\\cdot sum[r]-r=k\\cdot sum[l]-l\\)。 考虑根号分治。 对于 \\(k\\leq \\sqrt{n}\\)，直接暴力。 对于 \\(k&gt; \\sqrt{n}\\)，有 \\(sum[r]-sum[l] \\leq \\sqrt{n}\\)。 我们将原序列按照 \\(sum\\) 分段，枚举 \\(sum[l],sum[r],k\\)。相当于每次求左端点在 \\([l_1,r_1]\\)，右端点在 \\([l_2,r_2]\\)，且长为 \\(k(sum[r]-sum[l])\\) 的区间的个数。这个是可以 \\(O(1)\\) 统计的。 总复杂度 \\(O(n\\sqrt{n})\\)。 G.Subset with Zero Sum 题意：给定一个长为 \\(n\\) 的序列 \\(a\\)，\\(\\forall i\\in[1,n],i-n\\leq a_i\\leq i-1\\)。求一个子集，使得子集中元素的和为 \\(0\\)。 \\(\\forall i \\in[1,n],1\\leq i-a_i \\leq n\\)，我们从 \\(i\\) 向 \\(i - a_i\\) 连边。选取环上的元素即可。","link":"/2021/06/17/Good%20Bye%202019/"},{"title":"Hello 2020","text":"Hello 2020 A.New Year and Naming 题意：给定 \\(n\\) 个字符串 \\(s_i\\)，\\(m\\) 个字符串 \\(t_i\\)。第 \\(1\\) 个拼接字符串为 \\(s_1 + t_1\\)，两类字符串内部分别循环。给出 \\(q\\)，求第 \\(q\\) 个字符串。 把 \\(s,t\\) 均从 \\(0\\) 开始标号，那么答案为 \\(s_{(q-1)\\bmod n}+t_{(q-1)\\bmod m}\\)。 B.New Year and Ascent Sequence 题意：对于一个序列 \\(a\\)，如果 \\(\\exists i&lt;j,a_i&lt;a_j\\)，那么称这个序列是上升的。给定 \\(n\\) 个序列，求有多少对 \\((x,y)\\)，满足将第 \\(y\\) 个序列接在第 \\(x\\) 个序列之后，得到一个上升的序列。 考虑枚举 \\(y\\)，如果 \\(y\\) 是上升的贡献为 \\(n\\)，否则贡献为上升的序列个数，加上最小值小于序列 \\(y\\) 最大值的序列个数。 C.New Year and Permutation 题意：给定 \\(n\\)，求所有长为 \\(n\\) 的排列 \\(p\\) 中，有多少对数 \\((l,r)\\) 满足 \\(\\max_{i=l}^rp_i-\\min_{i=l}^rp_i=r-l\\)。 限制等价于子区间内部的数连续。 \\[ ans=\\sum_{i=1}^n(n-i+1)\\cdot i!\\cdot(n-i+1)! \\] D.New Year and Conference 题意：有 \\(n\\) 个讲座，每个讲座可以在 A 会场时间段 \\([l_A,r_A]\\) 举行，或者在 B 会场时间段 \\([l_B,r_B]\\) 举行。如果两个讲座被分配到同一个会场，且它们举行的时间段的交集不为空，那么它们不能一起举行。 求是否存在一个子集，将这个子集中的讲座都分配到某个会场可行，都分配到另一个会场不可行。 存在一个子集，相当于存在两个讲座，它们在一个会场冲突，在另一个会场不冲突。 那么我们可以钦定它们在 A 会场不冲突，在 B 会场冲突。（另一种情况同理） 求解可以使用扫描线，将所有讲座按照 \\(l_A\\) 排序。额外维护一个集合，按照 \\(r_A\\) 为关键字排序。这样我们可以快速的找出所有在 A 会场中和它不冲突的讲座。 求是否在 B 会场中产生冲突可以使用线段树，即区间加区间和。 由于只需要判断合法性，CYJian 在 这篇题解 中给出了一种更加简便的方式。 给每个讲座随机一个很大的权值。对于每个讲座，将两个会场中，和它不冲突的讲座的权值异或起来，如果不为 \\(0\\) 就认为存在冲突。 E.New Year and Castle Construction 题意：给定平面上点集 \\(S\\)。保证没有三点共线，且不存在重复点。记 \\(f(p)\\) 表示满足如下条件的四元集合 \\(T\\) 的个数。 \\(T\\subset S \\land p \\notin T\\) \\(T\\) 中的点能组成一个四边形，且满足 \\(p\\) 在四边形内部。 求 \\(\\sum_{p\\in S}f(p)\\)。 可以枚举 \\(p\\)。问题变成：平面直角坐标系上有若干个点，求有多少个四元子集，组成一个四边形，且满足原点在四边形内。 可以统计三角形，乘上 \\(\\frac{n-4}{2}\\) 就是答案。 我们将点按照极角排序，枚举点 \\(B,C\\)，那么第三个点可以是阴影中的点。 记 \\(ed[i]\\) 表示最靠后的，与 \\(i\\) 之间的夹角小于 \\(\\pi\\) 的点的位置。\\(ed\\) 可以用双指针求出。 那么答案为 \\(\\sum_{i=1}^n\\sum_{j=i+1}^{ed[i]}(ed[j]-ed[i])\\)，额外求 \\(ed\\) 的前缀和即可。","link":"/2021/06/10/Hello%202020/"},{"title":"Ozon Tech Challenge 2020","text":"Ozon Tech Challenge 2020 A.Kuroni and the Gifts 题意：给定两个长为 \\(n\\) 的序列 \\(a,b\\)，同一序列内元素两两不同。对两个序列进行重排使得 \\(\\forall i \\in [1,n],a_i+b_i\\) 两两不同。 直接两个序列都从小到大排就可以了。 B.Kuroni and the Gifts 题意：我们定义一个长为 \\(2k\\) 的括号序列是简单的，当且仅当 \\(1-k\\) 为 (，\\(k+1-2k\\) 为 )。给定一个括号序列。每次你可以选取一个简单的子序列并删去它。求至少需要删除多少次使得原序列中不存在简单子序列。 最终不存在好的子序列，因此原序列变成了一串 ) 后跟着一串 (。 所以我们需要找到一个位置，使得这个位置左边的 ( 和右边的 ) 都被删掉。所以答案要么为 \\(0\\)，要么为 \\(1\\)。因为删除一次和删除多次是等价的。 C.Kuroni and Impossible Calculation 题意：给定一个长为 \\(n\\) 的序列 \\(a\\)，和一个正整数 \\(m\\)。\\(n \\leq 10^5,m\\leq 1000\\)。求 \\(\\prod_{1\\leq i &lt;j \\leq n}|a_i-a_j| \\bmod m\\)。 若 \\(n &gt; m\\)，\\(\\exists i \\neq j,a_i \\equiv a_j \\pmod m\\)，此时答案为 \\(0\\)。所以直接暴力是 \\(O(m^2)\\) 的。 D.Kuroni and the Celebration 本题是一道交互题。 题意：给定一棵有 \\(n\\) 个节点的树。你可以询问两个点的 LCA。在 \\(\\lfloor \\frac{n}{2}\\rfloor\\) 次询问内找出这棵树的根。 每次我们询问两个叶节点，如果 LCA 是它们之一那么 LCA 就是根，否则我们将这两个点删去。 E.Kuroni and the Score Distribution 题意：给定 \\(m\\)，构造一个长为 \\(n\\) 的序列 \\(a\\)，满足以下条件： \\(1 \\leq a_1 &lt;a_2 &lt; a_3 &lt; \\cdots a_n \\leq 10^9\\) 满足 \\(i&lt;j&lt;k\\)，且 \\(a_i+a_j=a_k\\) 的三元组 \\((i,j,k)\\) 的数量恰好为 \\(m\\)。 使得三元组数量最大的构造：\\(1,2,3,\\cdots,n\\)。我们依次填数，填不够就直接判无解。否则我们会找到一个位置 \\(p\\)，使得前缀填 \\(1,2,3,\\cdots,p\\) 产生的三元组数量超过 \\(m\\)。这个时候我们发现，对于位置 \\(p\\) 上填的数，每增加 \\(2\\)，产生的三元组就会减少 \\(1\\)。我们将三元组调整到恰好 \\(m\\) 个后 ，记 \\(mx=ans[p]+1\\)。对于 \\([p+1,n]\\) 的数，我们填 \\(\\cdots,10^9-2mx,10^9-mx,10^9\\) 即可。 F.Kuroni and the Punishment 题意：给定长为 \\(n\\) 的序列 \\(a\\)，定义一次操作为选择一个数，将其 \\(+1\\) 或者 \\(-1\\)。求至少需要多少次操作，使得所有元素都为正数，且它们的 \\(\\gcd&gt;1\\)。 假设我们已经知道了在最优情况下它们的 \\(\\gcd=d\\)，那么操作次数是可以线性计算的。\\(ans=\\sum_i \\min\\begin{cases}a_i \\mod d &amp; a_i \\geq d \\\\ d-(a_i\\mod d)\\end{cases}\\) 当 \\(d=2\\) 时，操作次数不会超过 \\(n\\) 次，这是答案的上界。所以在最优情况下，至少存在 \\(\\frac{n}{2}\\) 个元素，改变的次数不超过 \\(1\\)。 所以我们在原序列中随机一个数 \\(x\\)，有 \\(\\frac{1}{2}\\) 的概率它最后被操作为 \\(x,x+1,x-1\\)。对于三种情况，我们对其分解质因数得到 \\(d\\)。随机 \\(20\\) 次即可达到 \\(10^{-6}\\) 的错误率。 G.Kuroni and Antihype 题意：给定一个长为 \\(n\\) 的序列 \\(a\\)。两个点 \\(i,j\\) 之间有边，当且仅当 \\(a_i\\;\\text{and}\\;a_j=0\\)。现在你可以进行如下操作： 将点 \\(i\\) 染色。 对于一个已经被染色的点 \\(u\\)，如果有边 \\((u,v)\\) 且 \\(v\\) 没有被染色，那么可以将 \\(v\\) 染色并且获得 \\(a_u\\) 的收益。 你需要将所有点染色，求最大收益。 我们添加一个虚拟点 \\(a_{n+1}=0\\)，将每条边 \\((u,v)\\) 边权赋为 \\(a_u+a_v\\)。这样我们就相当于要求出一个最大生成树，再减去 \\(\\sum a\\) 就是答案。 考虑 Kruskal 算法，我们将权值相同的点一同考虑。我们枚举边权 \\(w\\)，枚举其子集 \\(s\\)，那么 \\(s\\) 和 \\(w\\; \\text{xor}\\;s\\) 之间一定有边且边权为 \\(w\\)。记权值 \\(a_x\\) 在 \\(a\\) 中出现的次数为 \\(cnt[a_x]\\)，那么我们这样会产生 \\(w(cnt[s]+cnt[w\\;\\text{xor}\\;s]-1)\\) 的贡献。","link":"/2021/04/29/Ozon%20Tech%20Challenge%202020/"},{"title":"题解 ARC084D【XorShift】","text":"题目链接 题意：有 \\(n\\) 个数写在黑板上，有两种可以执行无限次的操作： 当 \\(x\\) 写在黑板上时把 \\(2x\\) 写在黑板上。 当 \\(x\\) 和 \\(y\\) 都写在黑板上时把 \\(x\\;\\text{xor}\\;y\\) 写在黑板上。 求最终有多少个 \\(\\leq lim\\) 的数能被写在黑板上。 除线性基之外，\\(\\mathbb{F}_2\\) 下的多项式也可以用来解决异或问题。 将给出的数看做 \\(\\mathbb{F}_2\\) 下的多项式，那么两种操作分别对应 \"乘 \\(x\\)\" 和 \"两个多项式相加 / 减\"。 利用这两个操作，我们可以求出两个多项式的 \\(\\gcd\\)。 记 \\(g\\) 为给出的 \\(n\\) 个多项式的 \\(\\gcd\\)，那么我们只能构造出 \\(g\\) 的倍数。 所以我们要求有多少个多项式 \\(P\\) 满足以下条件： \\(P\\) 是 \\(g\\) 的倍数。 \\(P\\) 转化为二进制数后 \\(\\leq M\\)。 分类讨论，如果 \\(\\deg(g)&gt;\\deg(lim)\\)，那么仅有 \\(0\\) 符合条件。 否则类似数位 \\(dp\\)，我们枚举钦定 \\(P\\) 的高位，然后低位任填。如果我们钦定了 \\(P\\) 的高位，只有第 \\(\\deg(g)-1\\) 位及之后没有填。那么剩下的填数方案是唯一确定的（即已钦定的部分对 \\(g\\) 取模） 设我们钦定到了第 \\(i\\) 位，\\(i\\geq \\deg(g)\\)，贡献为：\\(2^{i-\\deg(g)}\\)。 还有一种情况，\\(P\\) 的高位都与 \\(lim\\) 相同，只有第 \\(\\deg(g)-1\\) 位及之后可能不一样。特判处理即可（补全后判断是否 \\(\\leq lim\\)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct poly{ bitset&lt;maxn&gt; val; int deg; void trim(){ while(deg &amp;&amp; !val[deg])deg--; } poly operator % (const poly &amp;rhs)const{ poly res(*this); while(res.deg &gt;= rhs.deg){ res.val ^= rhs.val &lt;&lt; (res.deg - rhs.deg); res.trim(); if(res.deg == 0)break; } return res; } bool operator &lt;= (const poly &amp;rhs)const{ if(deg != rhs.deg)return deg &lt; rhs.deg; per(i,deg,0) if(val[i] != rhs.val[i])return val[i] &lt; rhs.val[i]; return true; }}g,lim,r;poly gcd(poly a,poly b){ while(a.val.any() &amp;&amp; b.val.any()){ if(a.deg &gt;= b.deg){ a.val ^= b.val &lt;&lt; (a.deg - b.deg); a.trim(); }else{ b.val ^= a.val &lt;&lt; (b.deg - a.deg); b.trim(); } } if(a.val.any())return a; else return b;}poly read(){ static char buf[maxn]; scanf(&quot;%s&quot;,buf); let len = strlen(buf); reverse(buf,buf + len); poly res; res.deg = len - 1; rep(i,0,res.deg)res.val[i] = buf[i] - '0'; return res;}int n,ans;int main(){ scanf(&quot;%d &quot;,&amp;n); lim = read(); repn(n)g = gcd(g,read()); if(g.deg &gt; lim.deg)return puts(&quot;1&quot;),0; per(i,lim.deg,g.deg) if(lim.val[i])ans = add(ans,qpow(2,i - g.deg)); r = lim; rep(i,0,g.deg - 1)r.val[i] = 0; r.val |= (r % g).val; if(r &lt;= lim)ans = add(ans,1); printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/2021/06/12/Solution%20ARC084D/"},{"title":"题解 CF755G【PolandBall and Many Other Balls】","text":"题目链接 题意：有 \\(n\\) 个球排成一排。一个组可以包含一个球或者两个相邻的球。一个球最多只能被分入一个组。求从这些球中选出 \\(k\\) 组的方案数。 显然有： \\[ S[n][k]=S[n-1][k]+S[n-1][k-1]+S[n-2][k-1] \\] 设 \\(F_n(x)\\) 表示答案的生成函数，有： \\[ F_n(x)=(1+x)F_{n-1}(x)+xF_{n-2}(x) \\] 可以用特征方程搞出其封闭形式： \\[ c^2-(1+x)c-x=0 \\] 从而： \\[ c_1=\\frac{1+x+\\sqrt{1+6x+x^2}}{2}\\\\ c_2=\\frac{1+x-\\sqrt{1+6x+x^2}}{2} \\] 可知： \\[ F_n(x)=k_1c_1^n+k_2c_2^n\\\\ \\begin{cases}k_1+k_2=1 \\\\ c_1k_1+c_2k_2=1+x\\end{cases} \\] 可以解出原式为： \\[ F_n(x)=\\frac{c_1^{n+1}-c_2^{n+1}}{\\sqrt{1+6x+x^2}} \\] 当 \\(x=0\\) 时，\\(c_2=0\\)，因此 \\(c_2^{n+1} \\equiv 0 \\pmod {x^{k+1}}\\) 因此： \\[ F_n(x)=\\frac{1}{\\sqrt{1+6x+x^2}}(\\frac{1+x+\\sqrt{1+6x+x^2}}{2})^{n+1} \\] 12345678910111213141516171819int main(){ const int n = io.readi(),k = io.readi(); poly f = {1,6,1}; f.resize(k + 1); f = sqrt(f); poly res = inv(f); f[0] = add(f[0],1); f[1] = add(f[1],1); for(auto &amp;x : f)x = mul(x,499122177); f = qpow(f,n + 1); gettr(f.size() + res.size() - 1); f.ntt();res.ntt(); res = f * res; res.ntt(-1);res.resize(k + 1); for(int i = 1;i &lt;= min(n,k);i++)io.write(res[i],' '); for(int i = n + 1;i &lt;= k;i++)io.write(0,' '); io.lf(); return 0;}","link":"/2021/05/10/Solution%20CF755G/"},{"title":"题解 CF891C【Envy】","text":"题目链接 题意：给定一张带权无向图，每次询问给出若干条边，求这些边能否在一棵最小生成树上。 关于最小生成树的结论： 对于任意权值的边，所有最小生成树中这个权值的边的数量是一定的。 对于任意正确加边方案，加完小于某权值的所有边后图的连通性是一样的。 也就是，我们按照边的权值对询问给出的边分类。将小于某类的边全部考虑之后，按连通块缩点。那么该类里面的所有边不会形成环。 可以离线下来，用按秩合并的并查集来支持撤销。 类似的题目：[JSOI2008]最小生成树计数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct edge{int u,v,w;}edges[maxm];struct node{ int id; vector&lt;pair&lt;int,int&gt;&gt; vec;};vector&lt;node&gt; vec[maxn];int n,m,q;bool ans[maxn];namespace dsu{ int f[maxn],siz[maxn]; void init(){rep(i,1,n)f[i] = i,siz[i] = 1;} stack&lt;pair&lt;int,int&gt;&gt; stk; int find(const int x){return x == f[x] ? x : find(f[x]);} bool merge(const int u,const int v){ int x = find(u),y = find(v); if(x == y)return false; if(siz[x] &gt; siz[y])swap(x,y); f[x] = y; siz[y] += siz[x]; stk.emplace(x,y); return true; } void back(const int lim){ while(stk.size() &gt; lim){ const auto [x,y] = stk.top();stk.pop(); f[x] = x; siz[y] -= siz[x]; } }}int main(){ io.read(n,m); rep(i,1,m)io.read(edges[i].u,edges[i].v,edges[i].w); io.read(q); rep(x,1,q){ vector&lt;int&gt; now; repn(io.readi())now.push_back(io.readi()); const auto cmp = [](auto a,auto b){return edges[a].w &lt; edges[b].w;}; sort(now.begin(),now.end(),cmp); auto it = now.begin(); while(it != now.end()){ const auto nxt = upper_bound(it,now.end(),*it,cmp); vector&lt;pair&lt;int,int&gt;&gt; ins; for_each(it,nxt,[&amp;](const auto x){ins.emplace_back(edges[x].u,edges[x].v);}); vec[edges[*it].w].push_back(node{x,ins}); it = nxt; } } fill(ans + 1,ans + 1 + q,true); sort(edges + 1,edges + 1 + m,[](auto a,auto b){return a.w &lt; b.w;}); dsu::init(); int pos = 1; rep(i,1,maxn - 1){ while(pos &lt;= m &amp;&amp; edges[pos].w &lt; i)dsu::merge(edges[pos].u,edges[pos].v),pos++; for(const auto &amp;[id,vec] : vec[i]){ const int mem = dsu::stk.size(); for(const auto [u,v] : vec)ans[id] = ans[id] &amp;&amp; dsu::merge(u,v); dsu::back(mem); } } rep(i,1,q)io.puts(ans[i] ? &quot;YES&quot; : &quot;NO&quot;); return 0;}","link":"/2021/05/24/Solution%20CF891C/"},{"title":"题解 LOJ6041【「雅礼集训 2017 Day7」事情的相似度】","text":"题目链接 题意：给定一个长为 \\(n\\) 的 \\(\\texttt{01}\\) 串，以及 \\(m\\) 次询问 \\([l,r]\\)。求右端点在 \\([l,r]\\) 内的不同前缀的最长公共后缀长度最大值。 对原串建一个 SAM，前缀的公共后缀对应 Parent 树上的公共祖先。那么我们要求的，即为从 \\([l,r]\\) 内选两个点，使得它们的 LCA 的深度尽量大。 离线下来扫描线，对于所有右端点为 \\(r\\) 的询问统一处理。 处理询问之前，我们要将某点 \\(p\\) 到根路径上的点全部打上新的标记，标记值为当前的 \\(r\\)。如果某个点已经有旧的标记，那么旧标记对应的位置就和新标记对应的位置在该点处产生贡献。根据决策包容性，这样不会漏解。这个操作实际上就是 LCT 的 access 操作。 我们还需要支持单点修改，求后缀 \\(\\max\\)，使用树状数组维护即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109char str[maxn];int n,m;namespace fenwick{ int f[maxn]; constexpr int lowbit(const int x){return x &amp; (-x);} void modify(int pos,const int v){ while(pos){ gmax(f[pos],v); pos -= lowbit(pos); } } int query(int pos){ int res = 0; while(pos &lt; maxn){ gmax(res,f[pos]); pos += lowbit(pos); } return res; }}namespace lct{ constexpr int maxnode = maxn &lt;&lt; 1; extern int faz[maxnode];}namespace sam{ constexpr int maxnode = maxn &lt;&lt; 1,sigma = 2; constexpr int idx(const char c){return c - '0';} int ch[maxnode][sigma],link[maxnode],len[maxnode],endpos[maxnode],tot = 1,lst = 1; void insert(const int c){ let now = ++tot; len[now] = len[lst] + 1; int p = lst; while(p &amp;&amp; !ch[p][c])ch[p][c] = now,p = link[p]; if(!p)link[now] = 1; else{ let q = ch[p][c]; if(len[p] + 1 == len[q])link[now] = q; else{ let clone = ++tot; len[clone] = len[p] + 1; copy_n(ch[q],sigma,ch[clone]); link[clone] = link[q]; while(p &amp;&amp; ch[p][c] == q)ch[p][c] = clone,p = link[p]; link[q] = link[now] = clone; } } lst = now; } void build(const char str[]){ rep(i,1,n)insert(idx(str[i])),endpos[i] = lst; rep(i,1,tot)lct::faz[i] = link[i]; }}namespace lct{ #define ls (ch[x][0]) #define rs (ch[x][1]) int ch[maxnode][2],faz[maxnode],val[maxnode],tag[maxnode]; bool chk(const int x){return ch[faz[x]][1] == x;} bool isroot(const int x){return (ch[faz[x]][0] != x) &amp;&amp; (ch[faz[x]][1] != x);} void rotate(const int x){ let y = faz[x],z = faz[y],k = (int)chk(x),w = ch[x][!k]; if(!isroot(y))ch[z][chk(y)] = x;ch[x][!k] = y;ch[y][k] = w; if(w)faz[w] = y;faz[y] = x;faz[x] = z; } void pushdown(const int x){ if(!tag[x])return; if(ls)val[ls] = tag[ls] = tag[x]; if(rs)val[rs] = tag[rs] = tag[x]; tag[x] = 0; } void splay(const int x){ static stack&lt;int&gt; stk; stk.push(x); for(int now = x;!isroot(now);now = faz[now])stk.push(faz[now]); while(!stk.empty())pushdown(stk.top()),stk.pop(); while(!isroot(x)){ let y = faz[x]; if(!isroot(y))rotate(chk(x) != chk(y) ? x : y); rotate(x); } } void access(int x,const int id){ for(int y = 0;x;x = faz[y = x]){ splay(x),ch[x][1] = y; fenwick::modify(val[x],sam::len[x]); val[x] = tag[x] = id; } } #undef ls #undef rs}struct Ques{int l,r,id;}q[maxn];int ans[maxn];int main(){ scanf(&quot;%d %d&quot;,&amp;n,&amp;m); scanf(&quot;%s&quot;,str + 1); sam::build(str); rep(i,1,m)scanf(&quot;%d %d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].id = i; sort(q + 1,q + 1 + m,[](const Ques &amp;lhs,const Ques &amp;rhs){ return lhs.r &lt; rhs.r; }); int pos = 1; rep(i,1,n){ lct::access(sam::endpos[i],i); while(pos &lt;= m &amp;&amp; q[pos].r == i)ans[q[pos].id] = fenwick::query(q[pos].l),pos++; } rep(i,1,m)printf(&quot;%d\\n&quot;,ans[i]); return 0;}","link":"/2021/07/08/Solution%20LOJ6041/"},{"title":"题解 P2150【[NOI2015] 寿司晚宴】","text":"题目链接 题意：从 \\(2,\\cdots,n\\) 中选取一些数放入 \\(X\\) 集合，选取一些数放入 \\(Y\\) 集合，要求 \\(\\forall x \\in X,y\\in Y \\quad \\gcd(x,y)=1\\)。求方案数。\\(n \\leq 500\\)。 首先有一个暴力，设 \\(f[S1][S2]\\) 表示两个集合的质因子集合分别为 \\(S1,S2\\) 时的方案数，直接转移即可。但是 \\(\\pi(500)=95\\) ，无法承受。 考虑到每个数至多只会有一个 \\(&gt; \\sqrt n\\) 的质因子，因此可以把所有数按照其 \\(&gt; \\sqrt n\\) 的质因子进行分类。逐类转移。 我们对每一类的数做背包，得到 \\(t[S]\\) 表示从中选数使得质因子集合为 \\(S\\) 的方案数。 那么 \\(f[S1][S2]=t[S1]\\cdot t[S2]\\) 否则 \\(f[S1][S2 \\cup S] \\leftarrow f[S1][S2\\cup S]+f[S1][S2]\\cdot t[S]\\)，另一种转移同理，上述方程均默认转移合法。 \\(\\pi(\\sqrt n)\\leq 8\\)，很稳。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071vector&lt;int&gt; pri,d[maxn],vec[maxn];int f[maxn][1 &lt;&lt; 8][1 &lt;&lt; 8],t[1 &lt;&lt; 8],lim,siz,ans,n;bool ispri[maxn];void init(){ static bool vis[maxn]; for(int i = 2;i &lt; maxn;i++){ if(!vis[i])pri.push_back(i); for(int x : pri){ if(i * x &gt;= maxn)break; vis[i * x] = 1; if(i % x == 0)break; } } for(int i = 2;i &lt; maxn;i++) if(!vis[i]){ siz += (i &lt;= lim); for(int j = i;j &lt; maxn;j += i)d[j].push_back(i); } for(int i = 2;i &lt; maxn;i++)ispri[i] = !vis[i];}int main(){ scanf(&quot;%d %d&quot;,&amp;n,&amp;mod); lim = sqrt(n); init(); for(int i = 2;i &lt;= n;i++){ if(d[i].back() &gt; lim)vec[find(pri.begin(),pri.end(),d[i].back()) - pri.begin() + 2].push_back(i); else vec[1].push_back(i); } int up = 0; for(int i = maxn - 1;i &gt;= 0;i--) if(!vec[i].empty()){ up = i; break; } t[0] = 1; for(const int x : vec[1]){ int status = 0; for(const int d : ::d[x]) if(d &lt;= lim)status |= 1 &lt;&lt; (find(pri.begin(),pri.end(),d) - pri.begin()); for(int s = (1 &lt;&lt; siz) - 1;s &gt;= 0;s--)t[s | status] = add(t[s | status],t[s]); } for(int s1 = 0;s1 &lt; (1 &lt;&lt; siz);s1++) for(int s2 = 0;s2 &lt; (1 &lt;&lt; siz);s2++) if(!(s1 &amp; s2))f[1][s1][s2] = mul(t[s1],t[s2]); for(int i = 2;i &lt;= up;i++){ memset(t,0,sizeof(t)); t[0] = 1; for(const int x : vec[i]){ int status = 0; for(const int d : ::d[x]) if(d &lt;= lim)status |= 1 &lt;&lt; (find(pri.begin(),pri.end(),d) - pri.begin()); for(int s = (1 &lt;&lt; siz) - 1;s &gt;= 0;s--)t[s | status] = add(t[s | status],t[s]); } t[0] = sub(t[0],1); for(int s1 = 0;s1 &lt; (1 &lt;&lt; siz);s1++) for(int s2 = 0;s2 &lt; (1 &lt;&lt; siz);s2++) f[i][s1][s2] = f[i - 1][s1][s2]; for(int status = 0;status &lt; (1 &lt;&lt; siz);status++) if(t[status])for(int s1 = 0;s1 &lt; (1 &lt;&lt; siz);s1++) for(int s2 = 0;s2 &lt; (1 &lt;&lt; siz);s2++){ if(!(s1 &amp; (s2 | status)))f[i][s1][s2 | status] = add(f[i][s1][s2 | status],mul(f[i - 1][s1][s2],t[status])); if(!(s2 &amp; (s1 | status)))f[i][s1 | status][s2] = add(f[i][s1 | status][s2],mul(f[i - 1][s1][s2],t[status])); } } for(int s1 = 0;s1 &lt; (1 &lt;&lt; siz);s1++) for(int s2 = 0;s2 &lt; (1 &lt;&lt; siz);s2++) ans = add(ans,f[up][s1][s2]); printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/2021/05/09/Solution%20P2150/"},{"title":"题解 P3974【[TJOI2015]组合数学】","text":"题目链接 题意：给定 \\(n\\times m\\) 的网格图，每个格子上有若干财宝。每次从左上角出发，只能往右或者下走，每次经过一个格子至多只能捡走一块财宝。求至少需要走几次才能捡走所有财宝。 把每个财宝当做一个点，那么就是 DAG 的最小可相交路径覆盖。 根据 Dilworth 定理，偏序集的最小链划分等于其反链长度的最大值。即 DAG 的最小可相交路径覆盖，等于 DAG 的最大独立集。 也就是从右上往左下选数，使得其权值之和最大。 可以用 dp 做。 12345678910111213141516171819int n,m,val[maxn][maxn];ll f[maxn][maxn];void solve(){ io.read(n,m); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++)io.read(val[i][j]); for(int i = 1;i &lt;= n;i++) for(int j = m;j &gt;= 1;j--){ f[i][j] = f[i - 1][j + 1] + val[i][j]; if(i != 1)chkmax(f[i][j],f[i - 1][j]); if(j != m)chkmax(f[i][j],f[i][j + 1]); } io.write(f[n][1],'\\n');}int main(){ int t = io.readi(); while(t--)solve(); return 0;}","link":"/2021/05/23/Solution%20P3974/"},{"title":"题解 P4161【[SCOI2009]游戏】","text":"题目链接 题意：给定 \\(n\\)，求长为 \\(n\\) 的置换有多少种各轮换大小的 \\(\\text{lcm}\\)。 注意到求 \\(\\text{lcm}\\) 是对所有质因子取其指数的 \\(\\max\\)。那么我们只需要对质数的幂次做背包就行了，这样显然不重不漏的覆盖了所有情况。 12345678910111213141516171819202122232425262728293031323334constexpr int maxn = 1e3 + 100;ll f[maxn][maxn],ans;int n;int vis[maxn];vector&lt;int&gt; pri;void sieve(){ for(int i = 2;i &lt; maxn;i++){ if(!vis[i])pri.push_back(i); for(int x : pri){ if(i * x &gt;= maxn)break; vis[i * x] = 1; if(i % x == 0)break; } }}int main(){ scanf(&quot;%d&quot;,&amp;n); sieve(); f[1][0] = 1; for(int i = 2;i &lt;= n;i++){ memcpy(f[i],f[i - 1],sizeof(f[i])); if(!vis[i]){ int now = i; while(now &lt;= n){ for(int s = now;s &lt;= n;s++) f[i][s] += f[i - 1][s - now]; now *= i; } } } for(int i = 0;i &lt;= n;i++)ans += f[n][i]; printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/2021/05/10/Solution%20P4161/"},{"title":"题解 P4921【[MtOI2018]情侣？给我烧了！（加强版）】","text":"题目链接 题意：有 \\(n\\) 排座位，每排包含 \\(2\\) 个座位。有 \\(n\\) 对情侣要入座，如果一对情侣坐在了同一排的座位上，那么这对情侣就是和睦的。多次给定 \\(n,k\\)，求有多少种就坐方案使得恰好有 \\(k\\) 对情侣是和睦的。 由二项式反演可知： \\[ A(x)=\\sum\\frac{(-1)^n2^n}{n!}x^n \\\\ B(x)=\\sum\\frac{(2n)!}{n!n!}x^n\\\\ C(x)=A\\times B\\\\ ans(n,x)=\\frac{[x^{n-x}]C(x)\\cdot n! \\cdot n! \\cdot 2^x}{x!} \\] 那么暴力卷积已经可以通过朴素版本了，但加强版数据范围过大 NTT 死掉了。 考虑使用生成函数搞出其递推式。 有 \\(A(x)=e^{-2x}\\) 对于 \\(B(x)=\\sum \\binom{2n}{n}x^n\\) 不是非常好处理，《具体数学》P154 给出了一个处理技巧——取一半。 \\[ r^{\\underline k}(r-\\frac{1}{2})^{\\underline k}=\\frac{(2r)^{\\underline{2k}}}{2^{2k}} \\] 那么在两边同时除以 \\(k!^2\\)，可以得到 \\[ \\binom{r}{k}\\binom{r-\\frac{1}{2}}{k}=\\frac{\\binom{2r}{2k}\\binom{2k}{k}}{2^{2k}} \\] 令 \\(k = r = n\\) 就可以得到： \\[ \\binom{n-\\frac{1}{2}}{n}=\\frac{\\binom{2n}{n}}{2^{2n}} \\] 所以有： \\[ \\binom{2n}{n}=4^{n}\\binom{n-\\frac{1}{2}}{n}=(-4)^n\\binom{-\\frac{1}{2}}{n}\\\\ B(x)=\\sum(-4x)^n\\binom{-\\frac{1}{2}}{n}=(1-4x)^{-\\frac{1}{2}} \\] 所以我们得到方程 \\(C(x)=\\frac{e^{-2x}}{\\sqrt{1-4x}}\\) 对其求导可以得到 \\(C'(x)=\\frac{8x}{1-4x}C(x)\\) 因此可以得到 \\[ [x^{n+1}]C(x)=\\frac{4n[x^n]C(x)+8[x^{n-1}]C(x)}{n+1} \\] 1234567891011121314151617181920212223242526int C[maxn],fac[maxn],ifac[maxn],pw[maxn],inv[maxn],t,n,x;void init(){ const int lim = 5e6; fac[0] = 1; for(int i = 1;i &lt;= lim;i++)fac[i] = mul(fac[i - 1],i); pw[0] = 1; for(int i = 1;i &lt;= lim;i++)pw[i] = mul(pw[i - 1],2); ifac[lim] = qpow(fac[lim],mod - 2); for(int i = lim - 1;i &gt;= 0;i--)ifac[i] = mul(ifac[i + 1],i + 1); inv[1] = 1; for(int i = 2;i &lt;= lim;i++) inv[i] = mul(mod - mod / i,inv[mod % i]); C[0] = 1; C[1] = 0; for(int n = 1;n &lt; lim;n++)C[n + 1] = mul(add(mul(4 * n,C[n]),mul(8,C[n - 1])),inv[n + 1]);}void solve(){ io.read(n,x); io.write(mul(C[n - x],fac[n],fac[n],pw[x],ifac[x]),'\\n');}int main(){ init(); io.read(t); while(t--)solve(); return 0;}","link":"/2021/05/07/Solution%20P4931/"},{"title":"题解 P4948【数列求和】","text":"题目链接 题意：给定 \\(n,a,k\\)，求 \\(\\sum_{i=1}^ni^ka^i\\) 扰动法的运用 \\[ \\begin{aligned} S(n,k)&amp;=\\sum_{i=1}^ni^ka^i\\\\ S(n,k)+(n+1)^ka^{n+1}&amp;=\\sum_{i =0}^{n}(i+1)^ka^{i+1}\\\\ &amp;=a\\cdot\\sum_{i =0}^{n}(i+1)^ka^i\\\\ &amp;=a\\cdot\\sum_{i=0}^n\\sum_{c=0}^k\\binom{k}{c}i^ca^i\\\\ &amp;=a\\cdot\\sum_{c=0}^k\\binom{k}{c}\\sum_{i=1}^ni^ca^i+a\\\\ &amp;=a\\cdot\\sum_{c=0}^k\\binom{k}{c}s(n,c)+a \\end{aligned} \\] 当 \\(a\\neq1\\) 时，有 \\[ S(n,k)=\\frac{(n+1)^ka^{n+1}-a\\cdot\\sum_{c=0}^{k-1}\\binom{k}{c}S(n,c)-a}{a-1} \\] 可以 \\(k^2\\) 递推。 当 \\(a=1\\) 时，有 \\[ \\begin{aligned} S(n,k)&amp;=\\sum_{i=1}^ni^k\\\\ S(n,k)+(n+1)^k&amp;=\\sum_{i=0}^n(i+1)^k\\\\ &amp;=\\sum_{c=0}^k\\binom{k}{c}S(n,c)+1\\\\ (n+1)^k&amp;=\\sum_{c=0}^{k-1}\\binom{k}{c}S(n,c)+1 \\end{aligned} \\] 所以 \\[ \\sum_{c=0}^k\\binom{k+1}{c}S(n,c)+1=(n+1)^{k+1}\\\\ S(n,k)=\\frac{(n+1)^{k+1}-\\sum_{c=0}^{k=1}\\binom{k+1}{c}S(n,c)-1}{k+1} \\] 也可以 \\(k^2\\) 递推。 12345678910111213141516171819202122232425262728293031ll n;int a,k,f[maxk],binom[maxk][maxk];int main(){ cin &gt;&gt; n &gt;&gt; a &gt;&gt; k; binom[0][0] = 1; for(int i = 1;i &lt; maxk;i++){ binom[i][0] = 1; for(int j = 1;j &lt;= i;j++)binom[i][j] = add(binom[i - 1][j - 1],binom[i - 1][j]); } if(a != 1){ f[0] = calc(sub(qpow(a,(n + 1) % (mod - 1)),a),a - 1); rep(v,1,k){ f[v] = mul(qpow((n + 1) % mod,v),qpow(a,(n + 1) % (mod - 1))); rep(c,0,v - 1)f[v] = sub(f[v],mul(a,binom[v][c],f[c])); f[v] = sub(f[v],a); f[v] = calc(f[v],a - 1); } }else{ f[0] = n % mod; rep(v,1,k){ f[v] = sub(qpow((n + 1) % mod,v + 1),1); rep(c,0,v - 1)f[v] = sub(f[v],mul(binom[v + 1][c],f[c])); f[v] = calc(f[v],v + 1); } int sum = 0; rep(i,1ll,n)sum = add(sum,qpow(i,k)); } cout &lt;&lt; f[k] &lt;&lt; '\\n'; return 0;}","link":"/2021/05/25/Solution%20P4948/"},{"title":"题解 P5644【[PKUWC2018]猎人杀】","text":"题目链接 题目大意：有 \\(n\\) 个猎人，第 \\(i\\) 个猎人的仇恨值是 \\(w_i\\)。每一轮，记当前还活着的猎人为 \\(i_1,\\cdots,i_m\\)，那么有 \\(\\frac{w_{i_k}}{\\sum_{j=1}^mw_{i_j}}\\) 的概率向猎人 \\(i_k\\) 开枪。求第一个猎人最后一个死的概率。 详见 OI Wiki，容斥原理一般化。（即子集反演） \\[ f(S)=\\sum_{T\\subseteq S}g(T)\\\\ \\iff g(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}f(T) \\] \\[ f(S)=\\sum_{S\\subseteq T}g(T)\\\\ \\iff g(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}f(T) \\] 证明就是奇偶抵消。 我们求第 \\(1\\) 个人最后死的概率，就是在求有 \\(0\\) 个人在他之后死的概率。 我们设 \\(f(S)\\) 表示集合 \\(S\\) 内的人在 \\(1\\) 之后死的概率，我们要求的就是 \\(f(\\emptyset)\\)。 另设一个 \\(g(S)\\) 表示钦点集合 \\(S\\) 内的人在 \\(1\\) 之后死，其余随意的概率。 那么有 \\[ g(S)=\\sum_{S\\subseteq T}f(T)\\\\ f(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}g(T) \\] 另一个关键的转化可以帮我们求出 \\(g(S)\\)。由于还活着的人不断变化，导致我们不好计算。我们可以转化为按照概率随意开枪，打到已经死了的人身上就重新打一枪，这样是等价的。 那么我们就需要枚举开了多少枪。 \\[ sum(S)=\\sum_{x\\in S}w_x\\\\ g(S)=\\sum_{i=0}^{\\infty}(\\frac{sum(U)-w_1-sum(S)}{sum(U)})^i\\frac{w_1}{sum(U)}=\\frac{w_1}{w_1+sum(S)} \\] 所以 \\[ \\begin{aligned} f(\\emptyset)&amp;=\\sum_{S}(-1)^{|S|}g(S)\\\\ &amp;=\\sum_{S}(-1)^{|S|}\\frac{w_1}{w_1+sum(S)} \\end{aligned} \\] 题目对 \\(\\sum w\\) 即 \\(sum(S)\\) 的范围做了限制。因此我们可以直接分治，求出在 \\([2,n]\\) 中，用奇数 / 偶数个 \\(w_i\\)，拼凑出 \\(sum(S)\\) 的方案数。 123456789101112131415161718192021222324252627int n,w[maxn],sum,ans;pair&lt;poly,poly&gt; solve(const int l,const int r){ if(l == r){ poly res(w[l] + 1); res[w[l]] = 1; return {res,poly{1}}; } const int mid = (l + r) &gt;&gt; 1; let &amp;&amp;[a,b] = solve(l,mid); let &amp;&amp;[c,d] = solve(mid + 1,r); return {times(a,d) + times(b,c),times(a,c) + times(b,d)};}int main(){ io.read(n); rep(i,1,n)io.read(w[i]),sum = add(sum,w[i]); let lim = sum + 1; auto &amp;&amp;[a,b] = solve(2,n); let x = w[1]; a.resize(lim); b.resize(lim); rep(i,0,sum) ans = sub(ans,mul(calc(x,x + i),a[i])); rep(i,0,sum) ans = add(ans,mul(calc(x,x + i),b[i])); io.write(ans,'\\n'); return 0;}","link":"/2021/05/27/Solution%20P5644/"},{"title":"网络流 24 题","text":"其实是 23 题。 洛谷 loj 餐巾计划问题 题意：一个餐厅在相继的 \\(N\\) 天里,每天需用的餐巾数不尽相同。假设第 \\(i\\) 天需要 \\(r_i\\) 块餐巾。餐厅可以购买新的餐巾,每块餐巾的费用为 \\(p\\) 分;或者把旧餐巾送到快洗部,洗一块需 \\(m\\) 天,其费用为 \\(f\\) 分;或者送到慢洗部,洗一块需 \\(n\\) 天\\((n&gt;m)\\),其费用为 \\(s\\) 分 \\((s&lt;f)\\)。 每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。 试设计一个算法为餐厅合理地安排好 \\(n\\) 天中餐巾使用计划,使总的花费最小。编程找出一个最佳餐巾使用计划。 将每个点拆点，分别表示脏餐巾和干净的餐巾。 从源点向脏餐巾点连边，容量为 \\(r_i\\)，费用为 \\(0\\)。 从干净餐巾点向汇点连边，容量为 \\(r_i\\)，费用为 \\(0\\)。 从源点向干净餐巾点连边，容量为 \\(r_i\\)，费用为 \\(p\\)。 每个脏餐巾点向对应干净餐巾点连边，容量为 \\(\\infty\\)，费用为 \\(f/s\\)。 从每个脏餐巾点向下一天的脏餐巾点连边，容量为 \\(\\infty\\)，费用为 \\(0\\)。 跑最小费用最大流即可。 星际转移问题 题意：由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。 现有 \\(n\\) 个太空站位于地球与月球之间，且有 \\(m\\) 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 \\(i\\) 艘太空船只可容纳 \\(h_i\\) 个人。每艘太空船将周期性地停靠一系列的太空站，例如 \\((1,3,4)\\) 表示该太空船将周期性地停靠太空站 \\(134134134\\dots\\)。每一艘太空船从一个太空站驶往任一太空站耗时均为 \\(1\\)。人们只能在太空船停靠太空站(或月球、地球)时上、下船。 初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。（只需要求最短时间） 人可以从某一站上船，在若干站以后下船，任意时刻船上的人不超过 \\(h_i\\)。我们将其转化为，到站之后所有人都下船，需要接着乘坐这艘船的再上船，否则原地等待。虽然在现实中看起来有病，但是限制条件被统一为：在时刻 \\(t\\rightarrow t+1\\)，我们可以从某一站向另一站运输 \\(h_i\\) 个人。 于是可以建立一个分层图模型。我们枚举答案 \\(ans\\)。如果第 \\(i\\) 艘船时刻 \\(t\\) 在 \\(u\\) 点，时刻 \\(t+1\\) 在 \\(v\\) 点，我们就从 \\(t\\) 层 \\(u\\) 点连向 \\(t+1\\) 层 \\(v\\) 点，容量为 \\(h_i\\)。\\(\\forall t&lt;ans\\)，从 \\(t\\) 层 \\(x\\) 点连向 \\(t+1\\) 层 \\(x\\) 点，容量为 \\(\\infty\\)。从 \\(1\\) 层地球向 \\(ans\\) 层月球跑最大流，超过 \\(k\\) 则可行。答案显然具有单调性。 飞行员配对方案问题 题意：第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。 一共有 \\(n\\) 个飞行员，其中有 \\(m\\) 个外籍飞行员和 \\((n - m)\\) 个英国飞行员，外籍飞行员从 \\(1\\) 到 \\(m\\) 编号，英国飞行员从 \\(m + 1\\) 到 \\(n\\) 编号。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 需要输出方案。 二分图最大匹配板子题 软件补丁问题 题意：T 公司发现其研制的一个软件中有 \\(n\\) 个错误，随即为该软件发放了一批共 \\(m\\) 个补丁程序。每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。 换句话说，对于每一个补丁 \\(i\\)，都有 \\(2\\) 个与之相应的错误集合 \\(B_1[i]\\) 和 \\(B_2[i]\\)，使得仅当软件包含 \\(B_1[i]\\)中的所有错误，而不包含 \\(B_2[i]\\) 中的任何错误时，才可以使用补丁 \\(i\\)。补丁 \\(i\\) 将修复软件中的某些错误 \\(F_1[i]\\)，而同时加入另一些错误 \\(F_2[i]\\)。另外，每个补丁都耗费一定的时间。 试设计一个算法，利用 T 公司提供的 \\(m\\) 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 \\(n\\) 个错误和 \\(m\\) 个补丁程序，找到总耗时最少的软件修复方案。 分层图（状态压缩）最短路。 太空飞行计划问题 题意：W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 \\(E = \\{ E_1, E_2, \\cdots, E_m \\}\\)，和进行这些实验需要使用的全部仪器的集合 \\(I = \\{ I_1, I_2, \\cdots, I_n \\}\\)。实验 \\(E_j\\) 需要用到的仪器是 \\(I\\) 的子集 \\(R_j \\subseteq I\\)。 配置仪器 \\(I_k\\) 的费用为 \\(c_k\\) 美元。实验 \\(E_j\\) 的赞助商已同意为该实验结果支付 \\(p_j\\) 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。 对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。 最大权闭合子图模型。即从实验向仪器连边，选择了一个实验就需要选择它依赖的全部仪器。 本题图特殊（二分图），在一般图中，最小割输出方案需要使用 dfs。 试题库问题 题意：假设一个试题库中有 \\(n\\) 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 \\(m\\) 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。 对于给定的组卷要求，计算满足要求的组卷方案。 从源点向每个题连边，容量为 \\(1\\)。从每个题向它的类别连边，容量为 \\(1\\)。从每个类别向汇点连边，容量为需求的题数。跑最大流即可。输出方案十分容易。 最小路径覆盖问题 题意：给定有向图 \\(G=(V,E)\\) 。设 \\(P\\) 是 \\(G\\) 的一个简单路(顶点不相交)的集合。如果 \\(V\\) 中每个定点恰好在 \\(P\\) 的一条路上，则称 \\(P\\) 是 \\(G\\) 的一个路径覆盖。\\(P\\) 中路径可以从 \\(V\\) 的任何一个定点开始，长度也是任意的，特别地，可以为 \\(0\\) 。\\(G\\) 的最小路径覆盖是 \\(G\\) 所含路径条数最少的路径覆盖。设计一个有效算法求一个 DAG (有向无环图) \\(G\\) 的最小路径覆盖。需要输出方案。 本题是 DAG 最小不相交路径覆盖的模板题。关于输出方案，如果二分图左侧点 \\(u\\) 匹配了右侧点 \\(v\\)，那么说明 \\(v\\) 要接在 \\(u\\) 后面，我们给 \\(v\\) 一个标记表示 \\(v\\) 不是链的起点，把 \\(u\\) 的后继赋为 \\(v\\) 即可。 魔术球问题 题意：有 \\(n\\) 根柱子，依照如下规则依次放入编号为 \\(1,2,3,\\cdots\\) 的球。 每次只能在某根柱子的最上面放球。 同一根柱子中，任何两个相邻球的编号之和为完全平方数。 求 \\(n\\) 根柱子最多可以放多少个球，以及求方案。 本题答案显然具有单调性，因此可以倍增。 假设我们要求 \\(1,2,\\cdots,m\\) 最少需要多少根柱子，如果 \\(u,v\\) 可以相邻，且 \\(u&lt;v\\)，我们就从 \\(u\\) 向 \\(v\\) 连边。问题变为 DAG 的最小不相交路径覆盖。 最长不下降子序列问题 题意：给定正整数序列 \\(x_1,x_2,\\cdots,x_n\\)。 计算其最长不下降子序列长度 \\(s\\)。 如果每个元素只允许使用一次，求最多可以取出多少个长为 \\(s\\) 的不下降子序列。 如果允许多次使用 \\(x_1,x_n\\)，求最多可以取出多少个不同的长度为 \\(s\\) 的不下降子序列。 第一问经典 \\(O(nlogn)\\)。 在第一问的基础上，我们求出了 \\(f[i]\\)，表示以 \\(i\\) 结尾的最长不下降子序列长度。 对于所有 \\(f[u]+1=f[v]\\quad u&lt;v\\)，\\(v\\) 可以接在 \\(u\\) 后面。 将每个点拆点，容量赋为 \\(1\\)。如果 \\(u\\) 可以转移到 \\(v\\)，就从 \\(u\\) 向 \\(v\\) 连边，容量为 \\(1\\)。从源点向所有 \\(f[i]=1\\) 的 \\(i\\) 连边，从所有 \\(f[i]=s\\) 的 \\(i\\) 向汇点连边，容量为 \\(1\\)。跑最大流即可。 第三问把 \\(x_1,x_n\\) 拆点的容量，和与源点汇点相连的点的容量改为 \\(\\infty\\) 即可 。需要特判 \\(s = 1\\)。 航空路线问题 题意：给定一张航空图，图中顶点代表城市，边代表两城市间的直通航线，并且不存在任何两个城市在同一条经线上。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线。 从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）。 除起点城市外，任何城市只能访问一次。、 要输出方案。 问题等价于，求两条从起点到终点的路径，它们除了起点和终点之外没有公共点，且经过的点尽量多。 将每个点拆点，对于起点和终点，容量为 \\(2\\)，费用为 \\(0\\)。对于其余点，容量为 \\(1\\)，费用为 \\(1\\)。如果有航线 \\((u,v) \\quad u &lt; v\\)，从 \\(u\\) 向 \\(v\\) 连容量为 \\(2\\)，费用为 \\(0\\) 的边。 从起点向终点跑最大费用最大流即可。如果流量跑不满 \\(2\\) 则无解。 关于输出方案，可以找到所有从西向东有流量的边，它们一定形成一个环。直接 dfs 找即可。 方格取数问题 题意：有一个 \\(m\\) 行 \\(n\\) 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。 将网格黑白染色，本题变为二分图最大独立集板子。也就是所有数的和减去最大匹配。 机器人路径规划问题 不会qwq 可以打表 12345678910111213#include &lt;cstdio&gt;using namespace std;int n;int main() { scanf(&quot;%d&quot;, &amp;n); if(n == 5) printf(&quot;3&quot;); else if(n == 13) printf(&quot;30&quot;); else if(n == 19) printf(&quot;20&quot;); else if(n == 100) printf(&quot;3&quot;); else if(n == 1000) printf(&quot;3&quot;); else printf(&quot;5&quot;); return 0;} 圆桌问题 题意：有来自 \\(m\\) 个不同单位的代表参加一次国际会议。第 \\(i\\) 个单位派出了 \\(r_i\\) 个代表。 会议的餐厅共有 \\(n\\) 张餐桌，第 \\(i\\) 张餐桌可容纳 \\(c_i\\) 个代表就餐。 为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。请给出一个满足要求的代表就餐方案。 从源点向每个单位连边，容量为 \\(r_i\\)。从每张餐桌向汇点连边，容量为 \\(c_i\\)。从每个单位向每张餐桌连容量为 \\(1\\) 的边。跑最大流。 如果某条单位到餐桌的边有流量，就代表这个单位派了一个代表到这张餐桌。 骑士共存问题 题意：在一个 \\(n \\times n\\) 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。 对于给定的 \\(n \\times n\\) 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。 二分图最大独立集板子。 火星探险问题 题意：火星探险队的登陆舱将在火星表面着陆，登陆舱内有多部障碍物探测车。登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。 探测车在移动中还必须采集岩石标本。每一块岩石标本由最先遇到它的探测车完成采集。每块岩石标本只能被采集一次。岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。探测车不能通过有障碍的地面。 本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失。 用一个 \\(p \\times q\\) 网格表示登陆舱与传送器之间的位置。登陆舱的位置在 \\((x_1,y_1)\\) 处，传送器的位置在 \\((x_py_q)\\) 处。 \\(\\begin{bmatrix} (x_1,y_1) &amp; (x_2,y_1) &amp; \\dots &amp; (x_{p-1},y_1) &amp; (x_p,y_1) \\\\ (x_1,y_2) &amp; (x_2,y_2) &amp; \\dots &amp; (x_{p-1},y_2) &amp; (x_p,y_2) \\\\ \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots \\\\ (x_1,y_{q-1}) &amp; (x_2,y_{q-1}) &amp; \\dots &amp; (x_{p-1},y_{q-1}) &amp; (x_p,y_{q-1}) \\\\ (x_1,y_q) &amp; (x_2,y_q) &amp; \\dots &amp; (x_{p-1},y_q) &amp; (x_p,y_q) \\end{bmatrix}\\) 给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多，在此前提下探测车采集到的岩石标本的数量最多。 将每个点拆点，如果不是障碍，则连容量为 \\(\\infty\\)，费用为 \\(0\\) 的边。如果是石块，则额外添加一条容量为 \\(1\\)，费用为 \\(1\\) 的边。 如果可以从 \\((x,y)\\) 到 \\((x',y')\\)，则从 \\((x,y)\\) 向 \\((x',y')\\) 连容量为 \\(\\infty\\)，费用为 \\(0\\) 的边。 跑最大费用最大流即可。 关于输出方案，我们看每个点拆点之后的边的流量，就可以求出每个点被经过的次数，直接 dfs。 最长k可重区间集问题 题意：给定实直线 \\(\\text{L}\\) 上 \\(n\\) 个开区间组成的集合 \\(\\mathbf{I}\\)，和一个正整数 \\(k\\)，试设计一个算法，从开区间集合 \\(\\mathbf{I}\\) 中选取出开区间集合 \\(\\mathbf{S}\\subseteq\\mathbf{I}\\)，使得在实直线 \\(\\text{L}\\) 上的任意一点 \\(x\\)，\\(\\text{S}\\) 中包含 \\(x\\) 的开区间个数不超过 \\(k\\)，且 \\(\\sum_{z\\in\\text{S}}\\lvert z\\rvert\\) 达到最大（\\(\\lvert z\\rvert\\) 表示开区间 \\(z\\) 的长度）。 这样的集合 \\(\\mathbf{S}\\) 称为开区间集合 \\(\\mathbf{I}\\) 的最长 \\(k\\) 可重区间集。\\(\\sum_{z\\in\\text{S}}\\lvert z\\rvert\\) 称为最长 \\(k\\) 可重区间集的长度。 对于给定的开区间集合 \\(\\mathbf{I}\\) 和正整数 \\(k\\)，计算开区间集合 \\(\\mathbf{I}\\) 的最长 \\(k\\) 可重区间集的长度。 本题类似于 [NOI2008] 志愿者招募，即类似区间覆盖问题的转化。 我们先将开区间离散化为闭区间 \\([l,r]\\)，记录其原始长度。 对于每个点 \\(i\\)，向 \\(i + 1\\) 连一条容量为 \\(k\\)，费用为 \\(0\\) 的边。 对于每个区间 \\([l,r]\\)，从 \\(l\\) 向 \\(r+1\\) 连一条容量为 \\(1\\)，费用为原始长度的边。 从源点向数轴起点连容量为 \\(k\\) 费用为 \\(0\\) 的边，从数轴终点向汇点连容量为 \\(k\\) 费用为 \\(0\\) 的边。 跑最大费用最大流即可。 最长k可重线段集问题 题意：给定平面 \\(x-O-y\\) 上 \\(n\\) 个开线段组成的集合 \\(I\\)，和一个正整数 \\(k\\) 。试设计一个算法，从开线段集合 \\(I\\) 中选取出开线段集合 \\(S\\subseteq I\\) ,使得在 \\(x\\) 轴上的任何一点 \\(p\\)，\\(S\\) 中与直线 \\(x=p\\) 相交的开线段个数不超过 \\(k\\)，且 \\(\\sum\\limits_{z\\in S}|z|\\) 达到最大。这样的集合 \\(S\\) 称为开线段集合 \\(I\\) 的最长 \\(k\\) 可重线段集。\\(\\sum\\limits_{z\\in S}|z|\\) 称为最长 \\(k\\) 可重线段集的长度。 对于任何开线段 \\(z\\)，设其断点坐标为 \\((x_0,y_0)\\) 和 \\((x_1,y_1)\\)，则开线段 \\(z\\) 的长度 \\(|z|\\) 定义为： \\(|z|=\\lfloor\\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}\\rfloor\\) 对于给定的开线段集合 \\(I\\) 和正整数 \\(k\\)，计算开线段集合 \\(I\\) 的最长 \\(k\\) 可重线段集的长度。 本题与上一道题相差无几，区别在于，线段垂直与 \\(x\\) 轴的时候，其投影是一个点。可以将投影等比例放大 \\(2\\) 倍。即上一题我们只关心整点的覆盖情况，现在我们关心所有形如 \\(0.5a\\) 的点的覆盖情况。 汽车加油行驶问题 题意：给定一个 \\(N \\times N\\) 的方形网格，设其左上角为起点 ◎，坐标 \\((1,1)\\)，\\(X\\) 轴向右为正， \\(Y\\) 轴向下为正，每个方格边长为 \\(1\\) ，如图所示。 一辆汽车从起点 ◎ 出发驶向右下角终点 ▲，其坐标为 \\((N,N)\\)。 在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则: 汽车只能沿网格边行驶，装满油后能行驶 \\(K\\) 条网格边。出发时汽车已装满油，在起点与终点处不设油库。 汽车经过一条网格边时，若其 \\(X\\) 坐标或 \\(Y\\) 坐标减小，则应付费用 \\(B\\) ，否则免付费用。 汽车在行驶过程中遇油库则应加满油并付加油费用 \\(A\\)。 在需要时可在网格点处增设油库，并付增设油库费用 \\(C\\)(不含加油费用 \\(A\\) )。 设计一个算法，求出汽车从起点出发到达终点所付的最小费用。 显然我们不会增设油库两次，可以跑分层图最短路。 分为 \\(k + 1\\) 层，第 \\(x\\) 层表示汽车还能行驶 \\(x\\) 条边。 对于第 \\(id\\) 层，如果点 \\((x,y)\\) 已有油库，且 \\(id \\neq k\\)，我们从第 \\(id\\) 层 \\((x,y)\\) 连向第 \\(k\\) 层 \\((x,y)\\) 边权为 \\(a\\)。 否则，如果 \\(id \\neq 0\\)，我们从第 \\(id\\) 层 \\((x,y)\\) 向第 \\(id -1\\) 层 \\((x',y')\\) 连边，权值为 \\(b\\) 或 \\(0\\)。从第 \\(id\\) 层 \\((x,y)\\) 向第 \\(k\\) 层 \\((x,y)\\) 连边，权值为 \\(c+a\\)。 建立一个虚拟终点 \\(t\\)，\\(\\forall id\\)，从第 \\(id\\) 层 \\((n,n)\\) 向 \\(t\\) 连边。第 \\(k\\) 层 \\((1,1)\\) 到 \\(t\\) 的最短路即为所求。 孤岛营救问题 题意：1944 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 \\(N\\) 行，东西方向被划分为 \\(M\\) 列，于是整个迷宫被划分为 \\(N\\times M\\) 个单元。每一个单元的位置可用一个有序数对(单元的行号，单元的列号)来表示。南北或东西方向相邻的 \\(2\\) 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成 \\(P\\) 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。 大兵瑞恩被关押在迷宫的东南角，即 \\((N,M)\\) 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 \\((1,1)\\) 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为 \\(1\\)，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。 试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。 分层图最短路，分 \\(2^P\\) 层，表示当前的钥匙集合。直接跑分层图最短路。 深海机器人问题 题意：深海资源考察探险队的潜艇将到达深海的海底进行科学考察。 潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。 深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。 每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。 本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。 用一个 \\(P\\times Q\\) 网格表示深海机器人的可移动位置。西南角的坐标为 \\((0,0)\\)，东北角的坐标为 \\((Q,P)\\) 。 给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值。 计算深海机器人的最优移动方案， 使深海机器人到达目的地后，采集到的生物标本的总价值最高。 不需要输出方案。 若 \\((x,y)\\) 可以到达 \\((x',y')\\)，则连一条容量为 \\(\\infty\\)，费用为 \\(0\\) 的边。再连一条容量为 \\(1\\)，费用为标本价值的边。 从源点向所有出发点连容量为 \\(k\\)，费用为 \\(0\\) 的边。从所有终点向汇点连容量为 \\(k\\)，费用为 \\(0\\) 的边。 跑最大费用最大流即可。 数字梯形问题 题意：给定一个由 \\(n\\) 行数字组成的数字梯形如下图所示。 梯形的第一行有 \\(m\\)个数字。从梯形的顶部的 \\(m\\) 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。 分别遵守以下规则： 从梯形的顶至底的 \\(m\\) 条路径互不相交； 从梯形的顶至底的 \\(m\\) 条路径仅在数字结点处相交； 从梯形的顶至底的 \\(m\\) 条路径允许在数字结点相交或边相交。 求分别依照三个规则行走，能获得的最大数字总和。 将每个点拆点，若 \\((x,y)\\) 能走到 \\((x',y')\\) 则连边。对于三种情况： 拆点的容量为 \\(1\\)，费用为点权。点之间的边容量为 \\(1\\)，费用为 \\(0\\)。 拆点的容量为 \\(\\infty\\)，费用为点权。点之间的边容量为 \\(1\\)，费用为 \\(0\\)。 拆点的容量为 \\(\\infty\\)，费用为点权。点之间的边容量为 \\(\\infty\\)，费用为 \\(0\\)。 分别跑最大费用最大流。 分配问题 题意：有 \\(n\\) 件工作要分配给 \\(n\\) 个人做。第 \\(i\\) 个人做第 \\(j\\) 件工作产生的效益为 \\(c_{ij}\\)。试设计一个将 \\(n\\) 件工作分配给 \\(n\\) 个人做的分配方案，使产生的总效益最大。 二分图最大带权匹配板子。 运输问题 题意：W 公司有 \\(m\\) 个仓库和 \\(n\\) 个零售商店。第 \\(i\\) 个仓库有 \\(a_i\\) 个单位的货物；第\\(j\\) 个零售商店需要 \\(b_j\\) 个单位的货物。 货物供需平衡，即 \\(\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j\\) 从第 \\(i\\) 个仓库运送每单位货物到第 \\(j\\) 个零售商店的费用为 \\(c_{ij}\\)。 试设计一个将仓库中所有货物运送到零售商店的运输方案，使总运输费用最少，或者最多。 从源点向每个仓库连边，容量为 \\(a_i\\)，费用为 \\(0\\)。从每个商店向汇点连边，容量为 \\(b_i\\)，费用为 \\(0\\)。从每个仓库向商店连边，容量为 \\(\\infty\\)，费用为 \\(c_{ij}\\)。 分别跑最小费用最大流，最大费用最大流。 负载平衡问题 题意：G 公司有个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。 本题与上下界网络流问题有着某种相似性。 首先求出所有仓库货物量的平均数，记为 \\(x\\)。记货物量为 \\(v_i\\)。 从源点，向所有货物量高于平均数的仓库连边，容量为 \\(v_i-x\\)，费用为 \\(0\\)。 从所有货物量低于平均数的仓库，向汇点连边，容量为 \\(x-v_i\\)，费用为 \\(0\\)。 从每个仓库，向相邻仓库连边，容量为 \\(\\infty\\)，费用为 \\(1\\)。 跑最小费用最大流即可。","link":"/2021/06/18/%E7%BD%91%E7%BB%9C%E6%B5%81%2024%20%E9%A2%98/"}],"tags":[{"name":"题集","slug":"题集","link":"/tags/%E9%A2%98%E9%9B%86/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"数学-位运算","slug":"数学-位运算","link":"/tags/%E6%95%B0%E5%AD%A6-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"数学-计数","slug":"数学-计数","link":"/tags/%E6%95%B0%E5%AD%A6-%E8%AE%A1%E6%95%B0/"},{"name":"数学-多项式","slug":"数学-多项式","link":"/tags/%E6%95%B0%E5%AD%A6-%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"数学-生成函数","slug":"数学-生成函数","link":"/tags/%E6%95%B0%E5%AD%A6-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"图论-生成树","slug":"图论-生成树","link":"/tags/%E5%9B%BE%E8%AE%BA-%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"雅礼集训","slug":"雅礼集训","link":"/tags/%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD/"},{"name":"数据结构-LCT","slug":"数据结构-LCT","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LCT/"},{"name":"字符串-后缀自动机","slug":"字符串-后缀自动机","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"NOI","slug":"NOI","link":"/tags/NOI/"},{"name":"动态规划-状压dp","slug":"动态规划-状压dp","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8Bdp/"},{"name":"各省省选","slug":"各省省选","link":"/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"},{"name":"动态规划-朴素dp","slug":"动态规划-朴素dp","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%B4%E7%B4%A0dp/"},{"name":"图论-Dilworth","slug":"图论-Dilworth","link":"/tags/%E5%9B%BE%E8%AE%BA-Dilworth/"},{"name":"洛谷","slug":"洛谷","link":"/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"PKUWC","slug":"PKUWC","link":"/tags/PKUWC/"},{"name":"数学-反演","slug":"数学-反演","link":"/tags/%E6%95%B0%E5%AD%A6-%E5%8F%8D%E6%BC%94/"},{"name":"数学-概率期望","slug":"数学-概率期望","link":"/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图论-网络流","slug":"图论-网络流","link":"/tags/%E5%9B%BE%E8%AE%BA-%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"categories":[{"name":"OI","slug":"OI","link":"/categories/OI/"}]}